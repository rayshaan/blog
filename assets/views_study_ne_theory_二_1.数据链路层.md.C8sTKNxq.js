import{_ as e,C as n,c as s,o as h,j as l,G as a,b1 as r,a as d}from"./chunks/framework.w2ptJf3g.js";const g=JSON.parse('{"title":"二.1.数据链路层","description":"","frontmatter":{},"headers":[],"relativePath":"views/study/ne/theory/二/1.数据链路层.md","filePath":"views/study/ne/theory/二/1.数据链路层.md","lastUpdated":1752568526000}'),u={name:"views/study/ne/theory/二/1.数据链路层.md"};function o(C,t,p,b,m,P){const i=n("ImageViewer");return h(),s("div",null,[t[0]||(t[0]=l("h1",{id:"二-1-数据链路层",tabindex:"-1"},[d("二.1.数据链路层 "),l("a",{class:"header-anchor",href:"#二-1-数据链路层","aria-label":'Permalink to "二.1.数据链路层"'},"​")],-1)),t[1]||(t[1]=l("h3",{id:"_1-数据链路层",tabindex:"-1"},[d("1.数据链路层 "),l("a",{class:"header-anchor",href:"#_1-数据链路层","aria-label":'Permalink to "1.数据链路层"'},"​")],-1)),t[2]||(t[2]=l("ul",null,[l("li",null,"在OSI模型中处在倒数第二层"),l("li",null,"把上层的数据封装成数据帧"),l("li",null,"对本层数据进行参数检测"),l("li",null,"在多路访问的广播网络中，还有寻址功能")],-1)),a(i,{src:"/blog/images/study/ne/数据链路层的作用.png",title:"数据链路层的作用"}),t[3]||(t[3]=r('<br><h3 id="_2-数据链路层信道类型" tabindex="-1">2.数据链路层信道类型 <a class="header-anchor" href="#_2-数据链路层信道类型" aria-label="Permalink to &quot;2.数据链路层信道类型&quot;">​</a></h3><ul><li>点对点信道(广域网)</li><li><ul><li>使用一对一的<span class="red">点对点</span>通信方式</li></ul></li><li>广播信道(局域网)</li><li><ul><li>使用一对多的<span class="red">广播通信</span>方式</li></ul></li><li><ul><li>必须使用专用的<span class="red">共享信道协议</span>来协议主机的数据发送</li></ul></li></ul><h3 id="_3-数据链路层的作用" tabindex="-1">3.数据链路层的作用 <a class="header-anchor" href="#_3-数据链路层的作用" aria-label="Permalink to &quot;3.数据链路层的作用&quot;">​</a></h3><ul><li>1.封装成帧</li><li>2.透明传输</li><li>3.差错控制</li></ul><h4 id="_1-封装成帧" tabindex="-1">1.封装成帧 <a class="header-anchor" href="#_1-封装成帧" aria-label="Permalink to &quot;1.封装成帧&quot;">​</a></h4><ul><li><span class="green">封装成帧(framing)</span>：在一段数据的前后分别添加首部和尾部，构成一个帧。</li><li>首部和尾部的一个重要作用就是进行帧定界(即确定帧的界限)。</li><li>控制字符SOH(Start of Header)放在一帧的最前面，表示帧的首部开始。</li><li>控制字符EOT(End of Transmission)放在一帧的末尾，表示帧的结束。</li></ul>',7)),a(i,{src:"/blog/images/study/ne/数据链路层-封装成帧.png",title:"数据链路层-封装成帧"}),t[4]||(t[4]=l("br",null,null,-1)),t[5]||(t[5]=l("h4",{id:"_2-透明传输",tabindex:"-1"},[d("2.透明传输 "),l("a",{class:"header-anchor",href:"#_2-透明传输","aria-label":'Permalink to "2.透明传输"'},"​")],-1)),t[6]||(t[6]=l("p",null,'问题：如果数据中的某个字节的二进制代码恰好和SOH和EOT一样，数据链路层就会错误地"找到帧的边界"，导致错误',-1)),a(i,{src:"/blog/images/study/ne/数据链路层-透明传输.png",title:"数据链路层-透明传输"}),t[7]||(t[7]=l("br",null,null,-1)),t[8]||(t[8]=l("p",null,"解决方法：",-1)),t[9]||(t[9]=l("ul",null,[l("li",null,"字节填充(异步)"),l("li",null,"零比特填充(同步)")],-1)),a(i,{src:"/blog/images/study/ne/透明传输差错解决方法.png",title:"透明传输差错解决方法"}),t[10]||(t[10]=l("br",null,null,-1)),t[11]||(t[11]=l("h4",{id:"_3-差错检测",tabindex:"-1"},[d("3.差错检测 "),l("a",{class:"header-anchor",href:"#_3-差错检测","aria-label":'Permalink to "3.差错检测"'},"​")],-1)),t[12]||(t[12]=l("p",null,"传输过程中可能会产生比特差错",-1)),t[13]||(t[13]=l("ul",null,[l("li",null,"原数据1 ==> 传递后0"),l("li",null,"原数据0 ==> 传递后1")],-1)),a(i,{src:"/blog/images/study/ne/数据链路层-差错检测.png",title:"数据链路层-差错检测"}),t[14]||(t[14]=l("br",null,null,-1)),t[15]||(t[15]=l("p",null,[d("在一段时间内，传输错误的比特占所传输比特总数的比特称为"),l("span",{class:"blue"},"误码率BER(Bit Error Rate)")],-1)),t[16]||(t[16]=l("h5",{id:"循环冗余检测crc",tabindex:"-1"},[d("循环冗余检测CRC "),l("a",{class:"header-anchor",href:"#循环冗余检测crc","aria-label":'Permalink to "循环冗余检测CRC"'},"​")],-1)),t[17]||(t[17]=l("ul",null,[l("li",null,"在发送端，先把数据划分为组。假定每组k个比特。"),l("li",null,"CRC运算在每组M后面再添加供差错检测用的n位冗余码，然后构成一个帧发送出去。一共发送(k + n)位。")],-1)),a(i,{src:"/blog/images/study/ne/循环冗余检测CRC.png",title:"循环冗余检测CRC"}),t[18]||(t[18]=l("br",null,null,-1)),t[19]||(t[19]=l("p",null,[d("这种为了进行检错而添加的冗余码常称为"),l("span",{class:"blue"},"帧检验序列FCS(Frame Check Sequence)")],-1)),t[20]||(t[20]=l("h6",{id:"crc冗余码计算",tabindex:"-1"},[d("CRC冗余码计算 "),l("a",{class:"header-anchor",href:"#crc冗余码计算","aria-label":'Permalink to "CRC冗余码计算"'},"​")],-1)),a(i,{src:"/blog/images/study/ne/CRC冗余码计算.png",title:"CRC冗余码计算"}),t[21]||(t[21]=l("br",null,null,-1)),t[22]||(t[22]=l("h6",{id:"crc冗余码计算示例",tabindex:"-1"},[d("CRC冗余码计算示例 "),l("a",{class:"header-anchor",href:"#crc冗余码计算示例","aria-label":'Permalink to "CRC冗余码计算示例"'},"​")],-1)),t[23]||(t[23]=l("p",null,"如果信息位为11001010101，生成多项式G(x) = x4 + x3 + x + 1，则校验码生成过程如下：",-1)),a(i,{src:"/blog/images/study/ne/CRC计算示例.png",title:"CRC计算示例"}),t[24]||(t[24]=r('<br><p>产生的余数为0011。那么发送端发送出去的信息位为11001010101<span class="green">0011</span></p><ul><li>多项式的最高次幂决定了冗余码的位数，几次幂就对应几位冗余码</li><li><ul><li>需要给原始信息补上冗余码位数再进行计算，例如补位0000</li></ul></li><li>除数位数是多项式最高次幂 + 1，例如4 + 1 = 5位</li><li>多项式计算除数：x的次方，有则为1，无则为0</li><li><ul><li>上述多项式，x4和x3和x1和x0都存在，就x2不存在，所以除数是11011</li></ul></li></ul><h6 id="生成多项式p-x" tabindex="-1">生成多项式P(X) <a class="header-anchor" href="#生成多项式p-x" aria-label="Permalink to &quot;生成多项式P(X)&quot;">​</a></h6><ul><li><span class="blue">CRC-16</span> = X16 + X15 + X2 + 1</li><li><span class="blue">CRC-CCITT</span> = X16 + X12 + X5 + 1</li><li><ul><li>PPP协议</li></ul></li><li><span class="blue">CRC-32</span> = X32 + X26 + X23 + X22 + X16 + X12 + X11 + X10 + X8 + X7 + X5 + X4 + X2 + X + 1</li><li><ul><li>以太网</li></ul></li></ul><h5 id="其他校验技术" tabindex="-1">其他校验技术 <a class="header-anchor" href="#其他校验技术" aria-label="Permalink to &quot;其他校验技术&quot;">​</a></h5><ul><li>奇校验：增加一位校验位，使1的个数为奇数</li><li>偶校验：增加一位校验位，使1的个数为偶数</li></ul><p><span class="brown">奇偶校验只有在出错二进制位个数是奇数的情况下才有效</span></p><h5 id="海明码" tabindex="-1">海明码 <a class="header-anchor" href="#海明码" aria-label="Permalink to &quot;海明码&quot;">​</a></h5><p>用冗余数据位来检测和纠正代码差错的理论和方法，特点：</p><ul><li>一般只能校验<span class="green">一位</span>数据错误</li><li><span class="green">校验位数量</span>：由2(k) ≥ m + k + 1决定，其中m为信息码，k为检验码</li><li><span class="green">校验位位置</span>：在2的幂次方位置上</li><li><span class="green">隐藏条件</span>：偶检验，确定校验位数值</li></ul><p>例如：信息码101101100，采用海明校验，问最终数据码是？</p><h6 id="_1-确定校验位数量" tabindex="-1">1.确定校验位数量 <a class="header-anchor" href="#_1-确定校验位数量" aria-label="Permalink to &quot;1.确定校验位数量&quot;">​</a></h6><ul><li>原信息码位数m = 9，代入公司：2(k) ≥ k + 10</li><li>假设k = 4，代入计算2(4) ≥ 4 + 10 即 16 ≥ 14，条件满足</li><li>确定校验位数量为4位</li></ul><h6 id="_2-确定校验位位置-2-0-1-2-1-2-2-2-4-2-3-8" tabindex="-1">2.确定校验位位置：2(0) = 1，2(1) = 2，2(2) = 4，2(3) = 8 <a class="header-anchor" href="#_2-确定校验位位置-2-0-1-2-1-2-2-2-4-2-3-8" aria-label="Permalink to &quot;2.确定校验位位置：2(0) = 1，2(1) = 2，2(2) = 4，2(3) = 8&quot;">​</a></h6><ul><li>确定校验关系：与位置的二进制数有关</li><li>确定校验位数值：对监督位做偶校验</li></ul><p>将原始9位信息码101101100，记为D1 ~ D9<br> 4位校验码，记为P1 ~ P4<br> 将校验码和信息码填入海明码位置(共9 + 4 = 13位)<br></p><table tabindex="0"><thead><tr><th>位置</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th></tr></thead><tbody><tr><td>标识</td><td>P1</td><td>P2</td><td>D1</td><td>P3</td><td>D2</td><td>D3</td><td>D4</td><td>P4</td><td>D5</td><td>D6</td><td>D7</td><td>D8</td><td>D9</td></tr><tr><td>值</td><td></td><td></td><td>1</td><td></td><td>0</td><td>1</td><td>1</td><td></td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><h6 id="_3-计算校验位-异或运算" tabindex="-1">3.计算校验位（异或运算） <a class="header-anchor" href="#_3-计算校验位-异或运算" aria-label="Permalink to &quot;3.计算校验位（异或运算）&quot;">​</a></h6><ul><li>每个校验位Pi负责位置二进制第i位为 1 的海明码位，通过异或这些位的信息码值得到Pi</li><li>将原始数据所在位置转为校验位长度的二进制数，例如原始数据第一位所在位置为3，3的二进制是11，校验位长度是4，补2个0为0011，以此类推</li></ul><p>将原始数据所在位置转为校验位长度的二进制数，得出：<br> 二进制第1位为1的位置 ==&gt; 3(D1)，5(D2)，7(D4)，9(D5)，11(D7)，13(D9)<br> 进行异或运算:P1 = 1⊕0⊕1⊕0⊕1⊕0 = 1<br> 以此类推，计算出：<br> P2 = 1⊕1⊕1⊕1⊕1 = 1<br> P3 = 0⊕1⊕1⊕0⊕0 = 0<br> P4 = 0⊕1⊕1⊕0⊕0 = 0<br></p><h6 id="_4-组装最终海明码" tabindex="-1">4.组装最终海明码 <a class="header-anchor" href="#_4-组装最终海明码" aria-label="Permalink to &quot;4.组装最终海明码&quot;">​</a></h6><table tabindex="0"><thead><tr><th>位置</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th></tr></thead><tbody><tr><td>标识</td><td>P1</td><td>P2</td><td>D1</td><td>P3</td><td>D2</td><td>D3</td><td>D4</td><td>P4</td><td>D5</td><td>D6</td><td>D7</td><td>D8</td><td>D9</td></tr><tr><td>值</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>最终数据码(海明码)：1110011001100</p><h6 id="接收方检测和纠错判断" tabindex="-1">接收方检测和纠错判断 <a class="header-anchor" href="#接收方检测和纠错判断" aria-label="Permalink to &quot;接收方检测和纠错判断&quot;">​</a></h6><table tabindex="0"><thead><tr><th>位置</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th></tr></thead><tbody><tr><td>标识</td><td>C1</td><td>C2</td><td>C3</td><td>C4</td><td>C5</td><td>C6</td><td>C7</td><td>C8</td><td>C9</td><td>C10</td><td>C11</td><td>C12</td><td>C13</td></tr><tr><td>值</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>接收方根据校验位位置，计算纠错码<br></p><ul><li>将第几位校验码和所在位置转为2进制数第几位为1的原始数据进行异或运算</li><li>例如：第一位：校验码C1(1)，C3(1)，C5(1)，C5(1)，C7(1)，C9(0)，C11(1)，C13(0)<br></li><li>进行异或运算得：1<br></li></ul><p>纠错码：</p><ul><li><p>第一位：C1 ⊕ C3 ⊕ C5 ⊕ C7 ⊕ C9 ⊕ C11 ⊕ C13</p></li><li><ul><li>1 ⊕ 1 ⊕ 1 ⊕ 1 ⊕ 1 ⊕ 0 ⊕ 1 ⊕ 0 = 1</li></ul></li><li><p>第二位：C2 ⊕ C3 ⊕ C6 ⊕ C7 ⊕ C10 ⊕ C11</p></li><li><ul><li>1 ⊕ 1 ⊕ 1 ⊕ 1 ⊕ 1 ⊕ 1 = 0</li></ul></li><li><p>第三位：C4 ⊕ C5 ⊕ C6 ⊕ C7 ⊕ C12 ⊕ C13</p></li><li><ul><li>0 ⊕ 1 ⊕ 1 ⊕ 1 ⊕ 0 ⊕ 0 = 1</li></ul></li><li><p>第四位：C8 ⊕ C9 ⊕ C10 ⊕ C11 ⊕ C12 ⊕ C13</p></li><li><ul><li>0 ⊕ 0 ⊕ 1 ⊕ 1 ⊕ 0 ⊕ 0 = 0</li></ul></li><li><p>在纠错码为1两个组合中，找只在他们组合中出现的交集，即第一位和第三位的交集，C5</p></li><li><p>C7，C13在第二位和第四位中也出现，排除</p></li><li><p>所以，C5第五位数据出错，原始数据为0，接收数据为1</p></li></ul>',30))])}const f=e(u,[["render",o]]);export{g as __pageData,f as default};
