import{_ as r,C as t,c as o,o as u,b1 as i,G as s,j as a,a as n}from"./chunks/framework.w2ptJf3g.js";const m=JSON.parse('{"title":"二.4.ARQ机制","description":"","frontmatter":{},"headers":[],"relativePath":"views/study/ne/theory/二/4.ARQ机制.md","filePath":"views/study/ne/theory/二/4.ARQ机制.md","lastUpdated":1752655198000}'),T={name:"views/study/ne/theory/二/4.ARQ机制.md"};function d(R,l,_,p,A,g){const e=t("ImageViewer");return u(),o("div",null,[l[0]||(l[0]=i('<h1 id="二-4-arq机制" tabindex="-1">二.4.ARQ机制 <a class="header-anchor" href="#二-4-arq机制" aria-label="Permalink to &quot;二.4.ARQ机制&quot;">​</a></h1><h3 id="_1-简介" tabindex="-1">1.简介 <a class="header-anchor" href="#_1-简介" aria-label="Permalink to &quot;1.简介&quot;">​</a></h3><ul><li>ARQ协议，即自动重传请求(Automatic Repeat-reQuest)，是OSI模型中的<span class="green">数据链路层</span>和<span class="green">传输层</span>错误纠正协议之一，它通过使用<span class="green">确认</span>和<span class="green">重传</span>这两个机制，在不可靠服务的基础上实现可靠的信息传输，一种面向连接的协议。</li><li>如果发送方在发送后一段时间内没有收到确认帧，它通常会重新发送。</li><li>重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。</li><li>ARQ包括<span class="green">停止等待ARQ协议</span>和<span class="green">连续ARQ协议</span>。</li></ul><p><span class="green">注：数据链路层的HDLC协议，传输层的TCP协议均使用了ARQ机制</span></p><h3 id="_2-停止等待arq协议" tabindex="-1">2.停止等待ARQ协议 <a class="header-anchor" href="#_2-停止等待arq协议" aria-label="Permalink to &quot;2.停止等待ARQ协议&quot;">​</a></h3><p>发送方和接收方都只有大小为1的滑动窗口。每当发送方发送一个分组时，就会开启一个计时器，一旦超时，就重发分组，这意味着，当收到接收方发来的ACK之前，发送方都必须将已发送的分组留在窗口中而不可删除。在收到确认后再发送下一个分组。</p>',6)),s(e,{src:"/blog/images/study/ne/停止等待ARQ.png",title:"停止等待ARQ"}),l[1]||(l[1]=a("br",null,null,-1)),l[2]||(l[2]=a("p",null,[a("span",{class:"green"},"分组错误、分组丢失会引发重传。确认丢失或迟到会引发重复帧")],-1)),l[3]||(l[3]=a("h4",{id:"信道利用率",tabindex:"-1"},[n("信道利用率 "),a("a",{class:"header-anchor",href:"#信道利用率","aria-label":'Permalink to "信道利用率"'},"​")],-1)),l[4]||(l[4]=a("ul",null,[a("li",null,"优点：简单"),a("li",null,"缺点：信道利用率太低")],-1)),s(e,{src:"/blog/images/study/ne/停止ARQ信道利用率.png",title:"停止ARQ信道利用率"}),l[5]||(l[5]=i('<br><h3 id="_3-连续arq" tabindex="-1">3.连续ARQ <a class="header-anchor" href="#_3-连续arq" aria-label="Permalink to &quot;3.连续ARQ&quot;">​</a></h3><ul><li>发送窗口：发送方维持一个发送窗口，位于发送窗口内的分组都可以被<span class="green">连续发送</span>出去，而不需要等待对方的确认。</li><li>发送窗口滑动：发送方每收到一个确认，就把发送方窗口<span class="green">向前滑动一个分组的位置</span>。</li><li>累计确认：接收方对<span class="green">按序到达的最后一个分组</span>发送确认，表示：到这个分组为止的所有分组都已正确收到了。</li></ul><h4 id="_1-流水线传输" tabindex="-1">1.流水线传输 <a class="header-anchor" href="#_1-流水线传输" aria-label="Permalink to &quot;1.流水线传输&quot;">​</a></h4><ul><li>流水线传输：在收到确认之前，发送方连续发出多个分组。</li><li>由于信道上一直有数据不间断地传送，流水线传输可获得很高的信道利用率。</li><li>连续ARQ协议和滑动窗口协议采用流水线传输方式。</li></ul>',5)),s(e,{src:"/blog/images/study/ne/连续ARQ-流水线传输.png",title:"连续ARQ-流水线传输"}),l[6]||(l[6]=a("br",null,null,-1)),l[7]||(l[7]=a("h4",{id:"_2-滑动窗口",tabindex:"-1"},[n("2.滑动窗口 "),a("a",{class:"header-anchor",href:"#_2-滑动窗口","aria-label":'Permalink to "2.滑动窗口"'},"​")],-1)),l[8]||(l[8]=a("ul",null,[a("li",null,"发送发维持发送窗口(大小为5)"),a("li",null,"收到一个确认后，发送窗口向前滑动")],-1)),s(e,{src:"/blog/images/study/ne/连续ARQ-滑动窗口.png",title:"连续ARQ-滑动窗口"}),l[9]||(l[9]=a("br",null,null,-1)),l[10]||(l[10]=a("h4",{id:"_3-累积确认",tabindex:"-1"},[n("3.累积确认 "),a("a",{class:"header-anchor",href:"#_3-累积确认","aria-label":'Permalink to "3.累积确认"'},"​")],-1)),l[11]||(l[11]=a("ul",null,[a("li",null,"优点：容易实现，效率高，即使确认丢失也不必重传。"),a("li",null,"缺点：不能向发送发反映出接收方已经正确收到的所有分组的信息。")],-1)),s(e,{src:"/blog/images/study/ne/连续ARQ-累积确认.png",title:"连续ARQ-累积确认"}),l[12]||(l[12]=i('<br><h4 id="_4-回退n帧" tabindex="-1">4.回退N帧 <a class="header-anchor" href="#_4-回退n帧" aria-label="Permalink to &quot;4.回退N帧&quot;">​</a></h4><ul><li>回退N帧GBN(Go-Back-N)</li><li>发送方收到ACK前可以同时连续发送多个分组</li><li><span class="green">最大发送窗口为序列化窗口-1，即≤2(n)-1，n表示帧需要字段的位数</span></li><li>但接收方<span class="green">只能缓冲一个分组</span>(窗口大小为1)</li><li>确认号ACK是<span class="green">累积</span>的，这对于ACK报文的丢失尤其有用</li></ul>',3)),s(e,{src:"/blog/images/study/ne/连续ARQ-回退N帧.png",title:"连续ARQ-回退N帧"}),l[13]||(l[13]=i('<br><h4 id="_5-选择重传" tabindex="-1">5.选择重传 <a class="header-anchor" href="#_5-选择重传" aria-label="Permalink to &quot;5.选择重传&quot;">​</a></h4><ul><li>选择重传SR(Selective Repeat)</li><li>发送窗口和接收窗口大小一致</li><li><span class="green">最大窗口为序列号窗口的一半，即≤2(n-1)，n表示帧编号字段的位数</span></li><li>接收窗口<span class="green">允许储存失序分组</span>，直到成为连续分组。</li><li>与GBN不同，SR的确认号<span class="green">不是累积</span>的，仅定义为本次收到的报文，对其他分组没有反馈。</li></ul>',3)),s(e,{src:"/blog/images/study/ne/连续ARQ-选择重传.png",title:"连续ARQ-选择重传"}),l[14]||(l[14]=i('<br><h4 id="_6-超时重传时间" tabindex="-1">6.超时重传时间 <a class="header-anchor" href="#_6-超时重传时间" aria-label="Permalink to &quot;6.超时重传时间&quot;">​</a></h4><ul><li>超时重传时间RTO(Retransmission Time-Out)</li><li>不能太短，否则会引起很多报文段的不必要的重传，使网络负荷增大。</li><li>不能过长，会使用网络的空闲时间增大，降低了传输效率。</li><li>主要参数往返时间RTT，称之为加权平均往返时间RTTs</li></ul><div class="formula"> 新的RTTs = (1 - α) x (旧的RTTs) + α x (新的RTT样本) </div><br><ul><li>其中，0 ≤ α &lt; 1</li><li>若α -&gt; 0，表示RTT值更新较慢</li><li>若α -&gt; 1，表示RTT值更新较快</li><li>RFC6298推荐的α值为1/8，即0.125</li></ul><p>RTO</p><ul><li>RTO应略大于加权平均往返时间RTTs</li><li>RFC6298建议RTO</li></ul><div class="formula"> RTO = RTTs + 4 x RTTd </div><br> - - 其中RTTd是RTT偏差的加权平均值 - RFC6298建议RTTd <div class="formula"> 新的RTTd = (1 - β) x (旧的RTTd) + β x | RTTs - 新的RTT样本 | </div><br> - - β是小于1的系数，其推荐值是1/4，即0.25',14))])}const Q=r(T,[["render",d]]);export{m as __pageData,Q as default};
