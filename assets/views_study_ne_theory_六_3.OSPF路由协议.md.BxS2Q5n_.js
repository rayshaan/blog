import{_ as n,C as i,c as d,o,b1 as s,G as a,j as l,a as r}from"./chunks/framework.w2ptJf3g.js";const _=JSON.parse('{"title":"六.3.OSPF路由协议","description":"","frontmatter":{},"headers":[],"relativePath":"views/study/ne/theory/六/3.OSPF路由协议.md","filePath":"views/study/ne/theory/六/3.OSPF路由协议.md","lastUpdated":1752226003000}'),S={name:"views/study/ne/theory/六/3.OSPF路由协议.md"};function p(u,t,P,b,h,A){const e=i("ImageViewer");return o(),d("div",null,[t[0]||(t[0]=s('<h1 id="六-3-ospf路由协议" tabindex="-1">六.3.OSPF路由协议 <a class="header-anchor" href="#六-3-ospf路由协议" aria-label="Permalink to &quot;六.3.OSPF路由协议&quot;">​</a></h1><h3 id="_1-特点" tabindex="-1">1.特点 <a class="header-anchor" href="#_1-特点" aria-label="Permalink to &quot;1.特点&quot;">​</a></h3><ul><li>1.OSPF把自治系统AS(Autonomous System)划分成逻辑意义上的一个或多个区域</li><li>2.OSPF通过<span class="green">LSA(Link State Advertisement)</span>的形式发布路由</li><li>3.OSPF依靠在OSPF区域内各设备间交互OSPF报文来达到路由信息的统一</li><li>4.OSPF报文封装在<span class="green">IP报文</span>内(<span class="brown">协议号89</span>)，可以采用<span class="brown">单播或组播</span>的形式发送</li></ul><h3 id="_2-链路状态路由协议工作过程" tabindex="-1">2.链路状态路由协议工作过程 <a class="header-anchor" href="#_2-链路状态路由协议工作过程" aria-label="Permalink to &quot;2.链路状态路由协议工作过程&quot;">​</a></h3>',4)),a(e,{src:"/blog/images/study/ne/链路状态路由协议工作过程.png",title:"链路状态路由协议工作过程"}),t[1]||(t[1]=s('<br><ul><li>1.建立相邻路由器之间的<span class="green">邻居关系</span></li><li>2.邻居之间交互链路状态信息和同步<span class="green">LSDB</span></li><li>3.进行<span class="green">优选路径</span>计算</li><li>4.根据最短路径树<span class="green">生成路由表项</span>加载到路由表</li></ul><h3 id="_3-ospf三大表项" tabindex="-1">3.OSPF三大表项 <a class="header-anchor" href="#_3-ospf三大表项" aria-label="Permalink to &quot;3.OSPF三大表项&quot;">​</a></h3><h4 id="_1-邻居表" tabindex="-1">1.邻居表 <a class="header-anchor" href="#_1-邻居表" aria-label="Permalink to &quot;1.邻居表&quot;">​</a></h4><ul><li>OSPF在传递链路状态信息之前，需先建立OSPF邻居关系</li><li>OSPF的邻居关系通过交互Hello报文建立</li><li>OSPF邻居表显示了OSPF路由器之间的邻居状态</li><li>使用display ospf peer查看</li></ul>',5)),a(e,{src:"/blog/images/study/ne/ospfpeer.png",title:"ospfpeer"}),t[2]||(t[2]=l("br",null,null,-1)),a(e,{src:"/blog/images/study/ne/OSPF邻居表.png",title:"OSPF邻居表"}),t[3]||(t[3]=l("br",null,null,-1)),t[4]||(t[4]=l("h4",{id:"_2-lsdb表",tabindex:"-1"},[r("2.LSDB表 "),l("a",{class:"header-anchor",href:"#_2-lsdb表","aria-label":'Permalink to "2.LSDB表"'},"​")],-1)),t[5]||(t[5]=l("ul",null,[l("li",null,"LSDB会保存自己产生的以及从邻居收到的LSA信息"),l("li",null,"Type标识LSA的类型，AdvRouter标识发送LSA的路由器"),l("li",null,"使用display ospf lsdb查看")],-1)),a(e,{src:"/blog/images/study/ne/ospflsdb.png",title:"ospflsdb"}),t[6]||(t[6]=l("br",null,null,-1)),a(e,{src:"/blog/images/study/ne/OSPFLSDB表.png",title:"OSPFLSDB表"}),t[7]||(t[7]=l("br",null,null,-1)),t[8]||(t[8]=l("h4",{id:"_3-路由表",tabindex:"-1"},[r("3.路由表 "),l("a",{class:"header-anchor",href:"#_3-路由表","aria-label":'Permalink to "3.路由表"'},"​")],-1)),t[9]||(t[9]=l("ul",null,[l("li",null,"OSPF路由表和路由器路由表是两张不同的表项"),l("li",null,"OSPF路由表包含Destination、Cost和NextHop等指导转发的信息"),l("li",null,"使用display ospf routing查看")],-1)),a(e,{src:"/blog/images/study/ne/ospfrouting.png",title:"ospfrouting"}),t[10]||(t[10]=l("br",null,null,-1)),a(e,{src:"/blog/images/study/ne/OSPFRouting表.png",title:"OSPFRouting表"}),t[11]||(t[11]=s('<br><h3 id="_4-ospf协议报文类型" tabindex="-1">4.OSPF协议报文类型 <a class="header-anchor" href="#_4-ospf协议报文类型" aria-label="Permalink to &quot;4.OSPF协议报文类型&quot;">​</a></h3><table tabindex="0"><thead><tr><th>报文名称</th><th>报文功能</th></tr></thead><tbody><tr><td>Hello</td><td>周期性发送，用来发现和维护OSPF邻居关系</td></tr><tr><td>Database Description</td><td>DB描述，描述本地LSDB的摘要信息，用于两台设备进行数据库同步</td></tr><tr><td>Link State Request</td><td>链路状态请求，用于向对方请求所需要的LSA。设备只有在OSPF邻居双方成功交换DD报文后才会向对方发出LSR报文</td></tr><tr><td>Link State Update</td><td>用于向对方发送其所需要的LSA</td></tr><tr><td>Link State ACK</td><td>链路状态确认，用来对收到的LSA进行确认</td></tr></tbody></table><h3 id="_5-ospf邻居状态机" tabindex="-1">5.OSPF邻居状态机 <a class="header-anchor" href="#_5-ospf邻居状态机" aria-label="Permalink to &quot;5.OSPF邻居状态机&quot;">​</a></h3>',4)),a(e,{src:"/blog/images/study/ne/OSPF邻居状态机.png",title:"OSPF邻居状态机"}),t[12]||(t[12]=s('<br><ul><li>Down：邻居的初始状态，还没收到Hello报文</li><li>Attempt：只在NBMA网络上存在，已发出Hello报文，但没收到回复</li><li>Init：已从邻居处收到了Hello报文，但报文邻居列表没有自己的ruter-id</li><li>2-Wait：已从邻居处收到了Hello报文，且报文邻居列表有自己的ruter-id</li><li>Exstart：向邻居发送DD报文，协商主从关系</li><li>Exchange：相互发送包含链路状态信息摘要的DD报文</li><li>Loading：相互发送LSR报文请求LSA，发送LSU报文通告LSA</li><li>Full：路由器的LSDB已经同步</li></ul><h4 id="名词解析" tabindex="-1">名词解析 <a class="header-anchor" href="#名词解析" aria-label="Permalink to &quot;名词解析&quot;">​</a></h4><ul><li>Router ID：32位的值，它标识了唯一的一个自治系统内的路由器</li><li>邻居(Neighbor)：状态到达2-way即可称为建立了邻居关系</li><li>邻接(Adjacency)：当双方成功交换DD报文，并同步LSDB后，才形成真正意义上的邻接关系</li></ul><h3 id="_6-工作过程" tabindex="-1">6.工作过程 <a class="header-anchor" href="#_6-工作过程" aria-label="Permalink to &quot;6.工作过程&quot;">​</a></h3><h4 id="_1-邻居发现" tabindex="-1">1.邻居发现 <a class="header-anchor" href="#_1-邻居发现" aria-label="Permalink to &quot;1.邻居发现&quot;">​</a></h4><p>Hello报文用来发现和维护OSPF邻居关系</p>',7)),a(e,{src:"/blog/images/study/ne/OSPF-Hello报文.png",title:"OSPF-Hello报文"}),t[13]||(t[13]=s('<br><p>验证一个接受到的Hello报文是否合法包括：</p><ul><li>1.如果接收端口的网络类型是广播型，点到多点或者NBMA，所接收的Hello报文中<span class="brown">Network Mask</span>字段必须和接收端口的网络掩码一致。如果接收端口的网络类型为点到点类型或者是虚连接，则不检查Network Mask字段</li><li>2.所接收的Hello报文中<span class="brown">Hello Interval</span>字段必须和接收端口的配置一致</li><li>3.所接收的Hello报文中的<span class="brown">Router Dead Interval</span>字段必须和接收端口的配置一致</li><li>4.所接收的Hello报文中<span class="brown">Options字段中的E-bit</span>(表示是否接收外部路由信息)必须和相关区域的配置一致</li></ul><h4 id="_2-同步数据库" tabindex="-1">2.同步数据库 <a class="header-anchor" href="#_2-同步数据库" aria-label="Permalink to &quot;2.同步数据库&quot;">​</a></h4><ul><li>路由器使用DD报文来进行主从路由器的选举和数据库摘要信息的交互</li><li>DD报文包含LSA的头部信息，用来描述LSDB的摘要信息</li><li>DD报文中的interface MTU两端要一致</li></ul>',5)),a(e,{src:"/blog/images/study/ne/OSPF工作过程-同步数据库.png",title:"OSPF工作过程-同步数据库"}),t[14]||(t[14]=l("br",null,null,-1)),t[15]||(t[15]=l("ul",null,[l("li",null,"1号和2号DD报文为空DD报文，用于协商主从，router-id大的一端胜出"),l("li",null,"3号和3号DD报文包含LSDB摘要信息"),l("li",null,"5号DD报文依然是空DD报文，用于对主路由器DD报文的确认")],-1)),t[16]||(t[16]=l("h4",{id:"_3-建立完全邻接关系",tabindex:"-1"},[r("3.建立完全邻接关系 "),l("a",{class:"header-anchor",href:"#_3-建立完全邻接关系","aria-label":'Permalink to "3.建立完全邻接关系"'},"​")],-1)),a(e,{src:"/blog/images/study/ne/OSPF工作过程-建立完全邻接关系.png",title:"OSPF工作过程-建立完全邻接关系"}),t[17]||(t[17]=s('<br><ul><li>LSR用于向对方请求所需的LSA</li><li>LSU用于向对方发送其所需要的LSA</li><li>LSACK用于向对方发送收到的LSA的确认</li></ul><h3 id="_7-dr与bdr" tabindex="-1">7.DR与BDR <a class="header-anchor" href="#_7-dr与bdr" aria-label="Permalink to &quot;7.DR与BDR&quot;">​</a></h3><ul><li>MA(Multi-Access)多路访问网络有两种类型：广播型多路访问网络(BMA)及非广播型多路访问网络(NBMA)。以太网(Ethernet)是一种典型的广播型多路访问网络</li><li>在MA网络中，如果每台OSPF路由器都与其他的所有路由器建立OSPF邻接关系，便会导致网路中存在过多的OSPF邻接关系，增加设备负担，也增加了网络中泛洪的OSPF报文数量</li><li>当拓扑出现变更，网络中的LSA泛洪可能会造成带宽的浪费和设备资源的损耗</li></ul><p>优化</p><ul><li>为优化MA网络中OSPF邻接关系，OSPF指定了三种OSPF路由器身份，<span class="green">DR(Designated Router)</span>和<span class="green">BDR(Backup Designated Router)</span>和<span class="green">DRother路由器</span></li><li>只允许DR、BDR与其他OSPF路由器建立邻接关系。<span class="brown">DRother之间不会建立</span>全毗邻的OSPF邻接关系，双方停滞在<span class="brown">2-way</span>状态。BDR会监控DR的状态，并在当前DR发生故障时接替其角色</li></ul><h3 id="_8-ospf支持的网络类型" tabindex="-1">8.OSPF支持的网络类型 <a class="header-anchor" href="#_8-ospf支持的网络类型" aria-label="Permalink to &quot;8.OSPF支持的网络类型&quot;">​</a></h3><p>OSPF(华为)定义了四种网络类型，缺省情况下，OSPF认为以太网的网络类型是广播类型，PPP、HDLC的网络类型是点到点类型</p><ul><li>1.点到点网络(P2P)</li><li>2.广播型网络(Broadcast)</li><li>3.NBMA网络(非广播多路访问)</li><li>4.点到多点网络(P2MP)</li></ul>',9)),a(e,{src:"/blog/images/study/ne/OSPF多路访问网络.png",title:"OSPF多路访问网络"}),t[18]||(t[18]=s('<br><ul><li>OSPF定义了两种支持多路访问的网络类型：非广播多路访问网络(NBMA)和点到多点网络(Point To Multi-Points)</li><li>NBMA每个路由器的邻居需要手动配置，以单播形式发送协议报文</li><li>缺省情况下，OSPF认为帧中继、ATM的网络类型是NBMA</li><li>没有一种链路层协议会被缺省的认为是P2MP类型</li></ul><h3 id="_9-ospf支持的网络类型汇总" tabindex="-1">9.OSPF支持的网络类型汇总 <a class="header-anchor" href="#_9-ospf支持的网络类型汇总" aria-label="Permalink to &quot;9.OSPF支持的网络类型汇总&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:center;">网络类型</th><th style="text-align:center;">HELLO</th><th style="text-align:center;">DEAD</th><th style="text-align:center;">HELLO 报文新方式</th><th style="text-align:center;">邻居建立方式</th><th style="text-align:center;">是否选举 DR/BDR</th></tr></thead><tbody><tr><td style="text-align:center;">广播类型</td><td style="text-align:center;">10s</td><td style="text-align:center;">40s</td><td style="text-align:center;">组播</td><td style="text-align:center;">自动发现</td><td style="text-align:center;">是</td></tr><tr><td style="text-align:center;">点到点</td><td style="text-align:center;">10s</td><td style="text-align:center;">40s</td><td style="text-align:center;">组播</td><td style="text-align:center;">自动发现</td><td style="text-align:center;">否</td></tr><tr><td style="text-align:center;">非广播多路访问</td><td style="text-align:center;">30s</td><td style="text-align:center;">120s</td><td style="text-align:center;">单播</td><td style="text-align:center;">手工指定</td><td style="text-align:center;">是</td></tr><tr><td style="text-align:center;">点到多点</td><td style="text-align:center;">30s</td><td style="text-align:center;">120s</td><td style="text-align:center;">组播</td><td style="text-align:center;">自动发现</td><td style="text-align:center;">否</td></tr></tbody></table><h3 id="_10-rip与is-is与bgp汇总" tabindex="-1">10.RIP与IS-IS与BGP汇总 <a class="header-anchor" href="#_10-rip与is-is与bgp汇总" aria-label="Permalink to &quot;10.RIP与IS-IS与BGP汇总&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:center;">路由协议</th><th style="text-align:center;">间隔更新时间</th><th style="text-align:center;">老化时间</th></tr></thead><tbody><tr><td style="text-align:center;">RIP</td><td style="text-align:center;">30s</td><td style="text-align:center;">180s</td></tr><tr><td style="text-align:center;">IS-IS</td><td style="text-align:center;">10s</td><td style="text-align:center;">30s</td></tr><tr><td style="text-align:center;">BGP</td><td style="text-align:center;">60s</td><td style="text-align:center;">180s</td></tr></tbody></table><h3 id="_11-ospf区域" tabindex="-1">11.OSPF区域 <a class="header-anchor" href="#_11-ospf区域" aria-label="Permalink to &quot;11.OSPF区域&quot;">​</a></h3>',7)),a(e,{src:"/blog/images/study/ne/OSPF区域.png",title:"OSPF区域"}),t[19]||(t[19]=s('<br><ul><li>非骨干区域要和骨干区域相连，非骨干区域之间不能互连，目的是防环</li><li>每个区域都维护一个<span class="brown">独立的LSDB</span></li><li><span class="brown">Area 0</span>是骨干区域，其他区域都必须与此区域相连</li><li>划分OSPF区域可以缩小路由器的LSDB规模，减少网络流量</li><li>区域内的详细拓扑信息不向其他区域发送，区域间传递的是抽象的路由信息</li></ul><h3 id="_12-常见lsa类型" tabindex="-1">12.常见LSA类型 <a class="header-anchor" href="#_12-常见lsa类型" aria-label="Permalink to &quot;12.常见LSA类型&quot;">​</a></h3><table tabindex="0"><thead><tr><th>LSA类型</th><th>LSA作用</th></tr></thead><tbody><tr><td>Router-LSA（Type1）</td><td><span class="red">每个设备</span>都会产生，描述了设备的链路状态和开销，在所属的区域内传播。</td></tr><tr><td>Network-LSA（Type2）</td><td>由<span class="red">DR（Designated Router）</span>产生，描述本网段的链路状态，在所属的区域内传播。</td></tr><tr><td>Network-summary-LSA（Type3）</td><td>由<span class="red">ABR</span>产生，描述区域内某个网段的路由，并通告给其它区域。</td></tr><tr><td>ASBR-summary-LSA（Type4）</td><td>由<span class="red">ABR</span>产生，描述到ASBR的路由，通告给除ASBR所在区域的其他相关区域。</td></tr><tr><td>AS-external-LSA（Type5）</td><td>由<span class="red">ASBR</span>产生，描述到AS外部的路由，通告到所有的区域（除了STUB区域和NSSA区域）。</td></tr><tr><td>NSSA LSA（Type7）</td><td>由<span class="red">ASBR</span>产生，描述到AS外部的路由，仅在NSSA区域内传播。</td></tr></tbody></table><h3 id="_13-ospf区域类型" tabindex="-1">13.OSPF区域类型 <a class="header-anchor" href="#_13-ospf区域类型" aria-label="Permalink to &quot;13.OSPF区域类型&quot;">​</a></h3><table tabindex="0"><thead><tr><th>区域类型</th><th>作用</th></tr></thead><tbody><tr><td>普通区域</td><td>缺省情况下，OSPF区域被定义为普通区域。<br><span class="red">接受所有类型LSA</span></td></tr><tr><td>STUB区域</td><td>不允许发布自治系统外部路由，只允许发布区域内路由和区域间的路由。<br><span class="red">只接收1类、2类、3类LSA</span></td></tr><tr><td>Totally STUB区域</td><td>不允许发布自治系统外部路由和区域间的路由，只允许发布区域内路由。<br><span class="red">只接收1类、2类LSA</span></td></tr><tr><td>NSSA区域</td><td>该区域既保留自治系统内的STUB区域的特征，又需要引入外部路由。<br><span class="red">生成7类LSA，只接收1类、2类、3类LSA</span></td></tr><tr><td>Totally NSSA区域</td><td>该区域既保留自治系统内的Totally STUB Area区域的特征，又需要引入外部路由。<br><span class="red">生成7类LSA，只接收1类、2类LSA</span></td></tr></tbody></table><h3 id="_14-ospf路由类型" tabindex="-1">14.OSPF路由类型 <a class="header-anchor" href="#_14-ospf路由类型" aria-label="Permalink to &quot;14.OSPF路由类型&quot;">​</a></h3><p>AS区域内和区域间路由描述的是AS内部的网络结构，AS外部路由则描述了应该如何选择到AS以外目的地址的路由。OSPF将引入的AS外部路由分为Type1和Type2两类</p><ul><li><span class="green">区域内路由(Intra Area)</span></li><li><span class="green">区域间路由(Inter Area)</span></li><li><span class="green">一类外部路由(Type1 External)</span><span class="brown">加内部开销</span></li><li><span class="green">二类外部路由(Type2 External)</span><span class="brown">不加内部开销</span></li></ul><h3 id="_15-ospf路由聚合" tabindex="-1">15.OSPF路由聚合 <a class="header-anchor" href="#_15-ospf路由聚合" aria-label="Permalink to &quot;15.OSPF路由聚合&quot;">​</a></h3><p>路由聚合是指ABR可以将具有相同前缀的路由信息聚合到一起，只发布一条路由¿其他区域。区域间通过路由聚合，可以减少路由信息，从而减小路由表的规模，提高设备的性能</p><ul><li><span class="green">ABR聚合</span>：ABR向其他区域发送路由信息时，以网段为单位生成Type3 LSA</li><li><span class="green">ASBR聚合</span>：配置路由聚合后，如果本地设备是自治系统边界路由器ASBR，将对引入的聚合地址范围内的Type5 LSA进行聚合</li></ul><h3 id="_16-ospf缺省路由" tabindex="-1">16.OSPF缺省路由 <a class="header-anchor" href="#_16-ospf缺省路由" aria-label="Permalink to &quot;16.OSPF缺省路由&quot;">​</a></h3><p>缺省路由是指目的地址和掩码都是0的路由。当设备无精确匹配的路由时，就可以通过缺省路由进行报文转发。由于OSPF路由的分级管理，Type3缺省路由的优先级高于Type5或Type7路由</p><ul><li><span class="green">由区域边界路由器(ABR)</span>发布Type3缺省Summary LSA，用来指导区域内设备进行区域之间报文的转发</li><li><span class="green">由自治系统边界路由器(ASBR)</span>发布Type5外部缺省ASE LSA，或者Type7外部缺省NSSA LSA，用来指导自治系统(AS)内设备进行自治系统外报文的转发 <br></li></ul><p><span class="brown">注：OSPF路由器只有具有对区域外的出口时，才能够发布缺省路由LSA</span></p><table tabindex="0"><thead><tr><th>区域类型</th><th>产生条件</th><th>发布方式</th><th>产生LSA类型</th><th>泛洪范围</th></tr></thead><tbody><tr><td>普通区域</td><td>通过default-route-advertise命令配置</td><td>ASBR发布</td><td>Type5 LSA</td><td>普通区域</td></tr><tr><td>Stub区域和Totally Stub区域</td><td>自动产生</td><td>ABR发布</td><td>Type3 LSA</td><td>Stub区域</td></tr><tr><td>NSSA区域</td><td>通过area default-route-advertise</td><td>ASBR发布</td><td>Type7 LSA</td><td>NSSA区域</td></tr><tr><td>Totally NSSA区域</td><td>自动产生</td><td>ABR发布</td><td>Type3 LSA</td><td>NSSA区域</td></tr></tbody></table><h3 id="_17-ospf配置" tabindex="-1">17.OSPF配置 <a class="header-anchor" href="#_17-ospf配置" aria-label="Permalink to &quot;17.OSPF配置&quot;">​</a></h3><h4 id="_1-基础配置" tabindex="-1">1.基础配置 <a class="header-anchor" href="#_1-基础配置" aria-label="Permalink to &quot;1.基础配置&quot;">​</a></h4>',19)),a(e,{src:"/blog/images/study/ne/OSPF基础配置.png",title:"OSPF基础配置"}),t[20]||(t[20]=l("br",null,null,-1)),t[21]||(t[21]=l("h4",{id:"_2-认证",tabindex:"-1"},[r("2.认证 "),l("a",{class:"header-anchor",href:"#_2-认证","aria-label":'Permalink to "2.认证"'},"​")],-1)),a(e,{src:"/blog/images/study/ne/OSPF认证.png",title:"OSPF认证"}),t[22]||(t[22]=l("br",null,null,-1)),t[23]||(t[23]=l("h4",{id:"_3-发布缺省路由",tabindex:"-1"},[r("3.发布缺省路由 "),l("a",{class:"header-anchor",href:"#_3-发布缺省路由","aria-label":'Permalink to "3.发布缺省路由"'},"​")],-1)),a(e,{src:"/blog/images/study/ne/OSPF发布缺省路由.png",title:"OSPF发布缺省路由"}),t[24]||(t[24]=l("br",null,null,-1)),t[25]||(t[25]=l("h4",{id:"_4-引入外部路由",tabindex:"-1"},[r("4.引入外部路由 "),l("a",{class:"header-anchor",href:"#_4-引入外部路由","aria-label":'Permalink to "4.引入外部路由"'},"​")],-1)),a(e,{src:"/blog/images/study/ne/OSPF引入外部路由.png",title:"OSPF引入外部路由"}),t[26]||(t[26]=l("br",null,null,-1)),t[27]||(t[27]=l("h3",{id:"_18-ospf静默接口-优化措施",tabindex:"-1"},[r("18.OSPF静默接口(优化措施) "),l("a",{class:"header-anchor",href:"#_18-ospf静默接口-优化措施","aria-label":'Permalink to "18.OSPF静默接口(优化措施)"'},"​")],-1)),t[28]||(t[28]=l("p",null,"通过Silent-Interface的配置，增强OSPF的组网适应能力，减少系统资源的消耗。Silent-Interface有一下特性：",-1)),t[29]||(t[29]=l("ul",null,[l("li",null,"Silent-Interface不会接收和发送OSPF报文"),l("li",null,"Silent-Interface的直连路由仍可以发布出去")],-1)),a(e,{src:"/blog/images/study/ne/OSPF静默接口.png",title:"OSPF静默接口"}),t[30]||(t[30]=s('<p>由于该接口上未连接任何其他OSPF路由器，因此管理员将该接口配置为Silent-Interface，该接口将不再收发Hello报文，从而避免了对Server的性能降低</p><h3 id="_19-ospf路由过滤" tabindex="-1">19.OSPF路由过滤 <a class="header-anchor" href="#_19-ospf路由过滤" aria-label="Permalink to &quot;19.OSPF路由过滤&quot;">​</a></h3><p>OSPF可以使用的路由策略包括route-policy，访问控制列表(access-list)，地址前缀列表(prefix-list) <br><br><span class="green">1.通过filter-police import命令对接收的路由设置过滤策略</span></p><ul><li><span class="brown">是对OSPF计算出来的路由进行过滤，不是对接收的LSA进行过滤</span></li><li>[Huawei] ospf 100</li><li>[Huawei-ospf-100] filter-policy 2000 import <br></li></ul><p><span class="green">2.通过filter-policy export命令对引入的路由在发布时进行过滤</span></p><ul><li><span class="brown">只将满足条件的外部路由转化为Type5 LSA(AS-external-LSA)并发布出去</span></li><li>[Huawei] ospf 100</li><li>[Huawei-ospf-100] import-route rip</li><li>[Huawei-ospf-100] filter-policy 2000 export rip 1</li></ul>',6))])}const y=n(S,[["render",p]]);export{_ as __pageData,y as default};
