import{_ as t,C as r,c as d,o,b1 as l,G as e,j as n,a as i}from"./chunks/framework.BbzeyoJx.js";const b=JSON.parse('{"title":"四.6.TCP拥塞控制","description":"","frontmatter":{},"headers":[],"relativePath":"views/study/ne/theory/四/6.TCP拥塞控制.md","filePath":"views/study/ne/theory/四/6.TCP拥塞控制.md","lastUpdated":1753693244000}'),c={name:"views/study/ne/theory/四/6.TCP拥塞控制.md"};function p(h,a,_,u,T,g){const s=r("ImageViewer");return o(),d("div",null,[a[0]||(a[0]=l('<h1 id="四-6-tcp拥塞控制" tabindex="-1">四.6.TCP拥塞控制 <a class="header-anchor" href="#四-6-tcp拥塞控制" aria-label="Permalink to &quot;四.6.TCP拥塞控制&quot;">​</a></h1><h3 id="_1-拥塞产生的原因" tabindex="-1">1.拥塞产生的原因 <a class="header-anchor" href="#_1-拥塞产生的原因" aria-label="Permalink to &quot;1.拥塞产生的原因&quot;">​</a></h3><ul><li>1.节点缓存容量太小</li><li>2.链路容量不足</li><li>3.处理机处理速率太慢</li><li>4.拥塞本身会进一步加剧拥塞</li></ul><h3 id="_2-拥塞控制与流量控制的区别" tabindex="-1">2.拥塞控制与流量控制的区别 <a class="header-anchor" href="#_2-拥塞控制与流量控制的区别" aria-label="Permalink to &quot;2.拥塞控制与流量控制的区别&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">拥塞控制</th><th style="text-align:left;">流量控制</th></tr></thead><tbody><tr><td style="text-align:left;">防止<span class="red">过多的数据注入</span>到网络中，避免网络中的路由器或链路过载</td><td style="text-align:left;"><span class="red">抑制发送端发送数据</span>的速率，以使接收端来得及接收</td></tr><tr><td style="text-align:left;">是一个<span class="red">全局性</span>的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素</td><td style="text-align:left;">点对点通信量的控制，是个<span class="red">端到端</span>的问题</td></tr></tbody></table><h3 id="_3-拥塞控制的作用" tabindex="-1">3.拥塞控制的作用 <a class="header-anchor" href="#_3-拥塞控制的作用" aria-label="Permalink to &quot;3.拥塞控制的作用&quot;">​</a></h3>',6)),e(s,{src:"/blog/images/study/ne/拥塞控制的作用.png",title:"拥塞控制的作用"}),a[1]||(a[1]=l('<br><h3 id="_4-tcp的拥塞控制方法" tabindex="-1">4.TCP的拥塞控制方法 <a class="header-anchor" href="#_4-tcp的拥塞控制方法" aria-label="Permalink to &quot;4.TCP的拥塞控制方法&quot;">​</a></h3><ul><li>TCP采用基于<span class="green">滑动窗口的方法</span>进行拥塞控制，属于闭环控制方法</li><li>TCP发送方维持一个<span class="green">拥塞窗口cwnd(Congestion Window)</span></li><li><span class="green">拥塞窗口</span>的大小取决于网络的拥塞程度，并且是<span class="green">动态变化</span>的</li><li>发送端利用<span class="green">拥塞窗口</span>根据网络的拥塞情况调整发送的数据量</li><li>发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况</li></ul><div class="formula"> 真正的发送窗口值 = Min(接收方通知的窗口值，拥塞窗口值) </div><h3 id="_5-控制拥塞窗口变化的原则" tabindex="-1">5.控制拥塞窗口变化的原则 <a class="header-anchor" href="#_5-控制拥塞窗口变化的原则" aria-label="Permalink to &quot;5.控制拥塞窗口变化的原则&quot;">​</a></h3><ul><li>只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，提高网络的利用率</li><li>但只要<span class="red">网络出现拥塞或有可能出现拥塞的情况</span>，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，缓解网络出现的拥塞</li><li>超时重传计时器超时，代表网络已出现了拥塞</li><li>收到3个重复的确认(帧)，预示网络可能会出现拥塞</li></ul><h3 id="_6-tcp拥塞控制算法" tabindex="-1">6.TCP拥塞控制算法 <a class="header-anchor" href="#_6-tcp拥塞控制算法" aria-label="Permalink to &quot;6.TCP拥塞控制算法&quot;">​</a></h3><ul><li>四种拥塞控制算法(RFC 5681)</li><li><ul><li>慢开始(slow-start)</li></ul></li><li><ul><li>拥塞避免(congestion avoidance)</li></ul></li><li><ul><li>快重传(fast retransmit)</li></ul></li><li><ul><li>快恢复(fast recovery)</li></ul></li></ul><h4 id="_1-慢开始-slow-start" tabindex="-1">1.慢开始(Slow start) <a class="header-anchor" href="#_1-慢开始-slow-start" aria-label="Permalink to &quot;1.慢开始(Slow start)&quot;">​</a></h4><ul><li>2个控制变量：拥塞窗口cwnd、慢开始门限ssthresh</li><li>拥塞窗口cwnd增大(指数级增长)：在每收到一个对新的报文段的确认，就把拥塞窗口增加最多一个发送方的最大报文段SMSS(Sender Maximum Segment Size)的数值</li></ul>',10)),e(s,{src:"/blog/images/study/ne/拥塞控制慢开始.png",title:"拥塞控制慢开始"}),a[2]||(a[2]=l('<br><h5 id="慢开始门限值ssthresh" tabindex="-1">慢开始门限值ssthresh <a class="header-anchor" href="#慢开始门限值ssthresh" aria-label="Permalink to &quot;慢开始门限值ssthresh&quot;">​</a></h5><ul><li>防止拥塞窗口cwnd增长过大引起网络拥塞</li><li>慢开始门限ssthresh的初始值为SMSS</li><li>当cwnd &lt; ssthresh时，使用慢开始算法</li><li>当cwnd &gt;= ssthresh时，停止使用慢开始算法，改用拥塞避免算法</li></ul><h4 id="_2-拥塞避免-congestion-avoidance" tabindex="-1">2.拥塞避免(Congestion avoidance) <a class="header-anchor" href="#_2-拥塞避免-congestion-avoidance" aria-label="Permalink to &quot;2.拥塞避免(Congestion avoidance)&quot;">​</a></h4><ul><li>目的：让拥塞窗口cwnd<span class="green">缓慢地增大</span>，避免出现拥塞</li><li><span class="red">拥塞窗口cwnd增大</span>：每经过一个往返时间RTT(不管在此期间收到了多少确认)，发送方的拥塞窗口cwnd = cwnd + 1</li><li>具有<span class="green">加法增大AI(Additive Increase)</span>特点：使拥塞窗口cwnd按线性规律缓慢增长</li></ul>',5)),e(s,{src:"/blog/images/study/ne/拥塞控制拥塞避免算法.png",title:"拥塞控制拥塞避免算法"}),a[3]||(a[3]=l('<br><h4 id="_3-当网络出现拥塞时" tabindex="-1">3.当网络出现拥塞时 <a class="header-anchor" href="#_3-当网络出现拥塞时" aria-label="Permalink to &quot;3.当网络出现拥塞时&quot;">​</a></h4><ul><li>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(<span class="green">重传定时器超时</span>)</li><li><ul><li><span class="green">1.ssthresh = max(cwnd/2，2)</span></li></ul></li><li><ul><li><span class="green">2.cwnd = 1</span></li></ul></li><li><ul><li><span class="green">3.执行慢开始算法</span></li></ul></li><li><span class="red">目的</span>：迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕</li></ul><h4 id="_3-快重传-fast-retransmit" tabindex="-1">3.快重传(Fast retransmit) <a class="header-anchor" href="#_3-快重传-fast-retransmit" aria-label="Permalink to &quot;3.快重传(Fast retransmit)&quot;">​</a></h4><ul><li><span class="red">目的</span>：让发送方尽早知道发生了个别报文段的丢失</li><li>发送方只要连续收到<span class="green">三个重复的确认</span>，就<span class="red">立即进行重传(快重传)</span>，这样就不会出现超时</li><li>使用快重传可以使整个网络的吞吐量提高约20%</li><li>快重传算法要求接收方<span class="green">立即发送确认</span>，即使收到了失序的报文段，也要立即发出对已收到的报文段的重复确认</li></ul>',5)),e(s,{src:"/blog/images/study/ne/拥塞控制快重传.png",title:"拥塞控制快重传"}),a[4]||(a[4]=l('<br><h4 id="_4-快恢复-fast-recovery" tabindex="-1">4.快恢复(Fast recovery) <a class="header-anchor" href="#_4-快恢复-fast-recovery" aria-label="Permalink to &quot;4.快恢复(Fast recovery)&quot;">​</a></h4><ul><li>当发送端收到三个重复的确认时，<span class="green">不执行</span>慢开始算法，而是执行<span class="green">快恢复算法FR(Fast Recovery)算法</span></li><li><ul><li>1.慢开始门限ssthresh = 当前拥塞窗口cwnd / 2</li></ul></li><li><ul><li>2.<span class="red">乘法减小MD(Multiplicative Decrease)</span>拥塞窗口</li></ul></li><li><ul><li><ul><li>新拥塞窗口cwnd = 慢开始门限ssthresh</li></ul></li></ul></li><li><ul><li>3.执行拥塞避免算法，使拥塞窗口缓慢地线性增大<span class="red">(加法增大AI)</span></li></ul></li></ul><h4 id="_5-tcp拥塞控制算法举例" tabindex="-1">5.TCP拥塞控制算法举例 <a class="header-anchor" href="#_5-tcp拥塞控制算法举例" aria-label="Permalink to &quot;5.TCP拥塞控制算法举例&quot;">​</a></h4>',4)),e(s,{src:"/blog/images/study/ne/TCP拥塞控制算法举例.png",title:"TCP拥塞控制算法举例"}),a[5]||(a[5]=l('<br><ul><li>1.当 TCP 连接进行初始化时，将<span class="green">拥塞窗口置为 1</span>（窗口单位不使用字节而使用报文段）。将慢开始门限的初始值设置为 16 个报文段，即 <span class="green">ssthresh = 16</span>。</li><li>2.执行<span class="green">慢启动算法</span>，拥塞窗口按<span class="green">指数</span>规律增长；当拥塞窗口cwnd增长到慢开始门限值ssthres时，改为执行<span class="green">拥塞避免算法</span>，拥塞窗口按<span class="green">线性</span>规律增长</li><li>3.当拥塞窗口 cwnd = 24 时，网络出现了<span class="red">超时</span>，发送方判断为<span class="red">网络拥塞</span>。调整门限值 <span class="red">ssthresh = cwnd / 2 = 12</span>，同时设置拥塞窗口 <span class="red">cwnd = 1，进入慢开始阶段</span>。</li><li>4.当拥塞窗口cwnd = 16时，发送方连续收到3个对同一个报文段的重复确认(记为<span class="red">3-AKC</span>)。发送方改为执行<span class="red">快重传和快恢复算法</span>。</li><li>5.执行快重传和快恢复算法：发送方调整门限值<span class="green">ssthresh = cwnd / 2 = 8</span>，设置拥塞窗口<span class="green">cwnd = ssthres = 8</span>，开始执行拥塞避免算法</li></ul><h4 id="_6-tcp拥塞控制流程图" tabindex="-1">6.TCP拥塞控制流程图 <a class="header-anchor" href="#_6-tcp拥塞控制流程图" aria-label="Permalink to &quot;6.TCP拥塞控制流程图&quot;">​</a></h4>',3)),e(s,{src:"/blog/images/study/ne/TCP拥塞控制流程图.png",title:"TCP拥塞控制流程图"}),a[6]||(a[6]=n("br",null,null,-1)),a[7]||(a[7]=n("ul",null,[n("li",null,[i("当rwnd < cwnd时，是"),n("span",{class:"brown"},"接收方的接收能力"),i("限制发送窗口的最大值")]),n("li",null,[i("当rwnd > cwnd时，是"),n("span",{class:"brown"},"网络拥塞限制"),i("发送窗口的最大值")])],-1))])}const m=t(c,[["render",p]]);export{b as __pageData,m as default};
