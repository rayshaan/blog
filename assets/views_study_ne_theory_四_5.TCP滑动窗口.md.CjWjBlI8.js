import{_ as r,C as t,c as u,o,b1 as n,G as i,j as a,a as s}from"./chunks/framework.BbzeyoJx.js";const g=JSON.parse('{"title":"四.5.TCP滑动窗口","description":"","frontmatter":{},"headers":[],"relativePath":"views/study/ne/theory/四/5.TCP滑动窗口.md","filePath":"views/study/ne/theory/四/5.TCP滑动窗口.md","lastUpdated":1753693244000}'),p={name:"views/study/ne/theory/四/5.TCP滑动窗口.md"};function d(_,l,T,P,C,b){const e=t("ImageViewer");return o(),u("div",null,[l[0]||(l[0]=n('<h1 id="四-5-tcp滑动窗口" tabindex="-1">四.5.TCP滑动窗口 <a class="header-anchor" href="#四-5-tcp滑动窗口" aria-label="Permalink to &quot;四.5.TCP滑动窗口&quot;">​</a></h1><h3 id="_1-以字节为单位的滑动窗口" tabindex="-1">1.以字节为单位的滑动窗口 <a class="header-anchor" href="#_1-以字节为单位的滑动窗口" aria-label="Permalink to &quot;1.以字节为单位的滑动窗口&quot;">​</a></h3><ul><li>TCP使用<span class="green">流水线传输</span>和<span class="green">滑动窗口协议</span>实现高效、可靠的传输</li><li>TCP的滑动窗口是以字节为单位的</li><li>发送方A和接收方B分别维持一个发送窗口和接收窗口</li><li><ul><li>发送窗口：在没有收到确认的情况下，发送方可以连续把窗口内的数据全部发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用</li></ul></li><li><ul><li>接收窗口：只允许接收落入窗口内的数据</li></ul></li></ul><h4 id="_1-tcp滑动窗口的具体工作过程" tabindex="-1">1.TCP滑动窗口的具体工作过程 <a class="header-anchor" href="#_1-tcp滑动窗口的具体工作过程" aria-label="Permalink to &quot;1.TCP滑动窗口的具体工作过程&quot;">​</a></h4>',4)),i(e,{src:"/blog/images/study/ne/TCP滑动窗口的具体工作过程.png",title:"TCP滑动窗口的具体工作过程"}),l[1]||(l[1]=a("br",null,null,-1)),l[2]||(l[2]=a("ul",null,[a("li",null,[s("发送方窗口移动是由发送数据是否"),a("span",{class:"red"},"被确认"),s("来决定的")]),a("li",null,[s("接收方窗口移动是由接收数据是否"),a("span",{class:"red"},"按需收到"),s("来决定的")])],-1)),l[3]||(l[3]=a("h4",{id:"_2-发送缓存与发送窗口",tabindex:"-1"},[s("2.发送缓存与发送窗口 "),a("a",{class:"header-anchor",href:"#_2-发送缓存与发送窗口","aria-label":'Permalink to "2.发送缓存与发送窗口"'},"​")],-1)),i(e,{src:"/blog/images/study/ne/TCP发送缓存.png",title:"TCP发送缓存"}),l[4]||(l[4]=a("br",null,null,-1)),l[5]||(l[5]=a("ul",null,[a("li",null,"发送方的应用进程把字节流写入TCP发送缓存"),a("li",null,"发送窗口通常只是发送缓存的一部分"),a("li",null,"不能发送太快，否则发送缓存会溢出")],-1)),l[6]||(l[6]=a("div",{class:"formula"}," 缓存中的字节数 = 发送应用程序最后写入缓存的字节 - 最后被确认的字节 ",-1)),l[7]||(l[7]=a("h4",{id:"_3-接收缓存与接收窗口",tabindex:"-1"},[s("3.接收缓存与接收窗口 "),a("a",{class:"header-anchor",href:"#_3-接收缓存与接收窗口","aria-label":'Permalink to "3.接收缓存与接收窗口"'},"​")],-1)),i(e,{src:"/blog/images/study/ne/TCP接收缓存.png",title:"TCP接收缓存"}),l[8]||(l[8]=n('<br><ul><li>接收方的应用进程从TCP接收缓存中读取尚未被读取的字节</li><li>暂时存放</li><li><ul><li>按序到达的、但尚<span class="red">未被</span>接收应用程序读取的数据</li></ul></li><li><ul><li><span class="red">未按序到达</span>的数据</li></ul></li><li>若不能及时读取，缓存最终会被填满，使接收窗口减小到零</li><li>若能及时读取，接收窗口就可以增大，但最大不能超过接收缓存的大小</li></ul><h4 id="_4-滑动窗口小结" tabindex="-1">4.滑动窗口小结 <a class="header-anchor" href="#_4-滑动窗口小结" aria-label="Permalink to &quot;4.滑动窗口小结&quot;">​</a></h4><ul><li>发送窗口是根据接收窗口设置的，但在同一时刻，发送窗口并<span class="green">不总是</span>和接收窗口<span class="green">一样大</span>(因为有一定的时间滞后)</li><li>TCP标准<span class="green">没有规定</span>对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再<span class="green">按序交付</span>上层的应用进程</li><li>TCP要求接收方必须有<span class="green">累积确认</span>功能，以减小传输开销。接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便<span class="green">捎带</span>上。但接收方<span class="green">不应过分推迟</span>发送确认，否则会导致发送方不必要的重传</li></ul><h3 id="_2-利用滑动窗口实现流量控制" tabindex="-1">2.利用滑动窗口实现流量控制 <a class="header-anchor" href="#_2-利用滑动窗口实现流量控制" aria-label="Permalink to &quot;2.利用滑动窗口实现流量控制&quot;">​</a></h3><ul><li><span class="green">流量控制(flow control)</span>：让发送方的发送速率不要太快，使接收方来得及接收</li><li>利用<span class="brown">可变窗口机制</span>可以很方便地在TCP连接上实现对发送方流量的控制</li></ul>',6)),i(e,{src:"/blog/images/study/ne/TCP滑动窗口流量控制.png",title:"TCP滑动窗口流量控制"}),l[9]||(l[9]=n('<br><h3 id="_3-可能发生的问题" tabindex="-1">3.可能发生的问题 <a class="header-anchor" href="#_3-可能发生的问题" aria-label="Permalink to &quot;3.可能发生的问题&quot;">​</a></h3><h4 id="_1-死锁" tabindex="-1">1.死锁 <a class="header-anchor" href="#_1-死锁" aria-label="Permalink to &quot;1.死锁&quot;">​</a></h4><ul><li><span class="green">持续计时器(persistence timer)</span>：只要TCP连接的一方收到对方的零窗口通知，就启动该持续计时器</li><li><ul><li>若计时器设置的时间到期，就发送一个<span class="red">零窗口探测</span>报文段(仅携带1字节的数据)，对方在确认这个探测报文段时给出当前窗口值</li></ul></li><li><ul><li>若窗口仍然是零，收到这个报文段的一方就重新设置持续计时器</li></ul></li><li><ul><li>若窗口不是零，则死锁的僵局就可以打破了</li></ul></li></ul><h4 id="_2-发送方糊涂窗口综合症" tabindex="-1">2.发送方糊涂窗口综合症 <a class="header-anchor" href="#_2-发送方糊涂窗口综合症" aria-label="Permalink to &quot;2.发送方糊涂窗口综合症&quot;">​</a></h4>',5)),i(e,{src:"/blog/images/study/ne/TCP发送方糊涂窗口综合症.png",title:"TCP发送方糊涂窗口综合症"}),l[10]||(l[10]=n('<br><ul><li>糊涂窗口综合症：每次仅发送一个字节或很少几个字节的数据时，有效数据传输效率变得很低的现象</li><li>控制TCP发送报文段的时机：三种机制</li><li><ul><li>1.TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到<span class="brown">MSS字节</span>时，就组装成一个TCP报文段发送出去</li></ul></li><li><ul><li>2.由发送方的应用进程指明要求发送报文段，即TCP支持的<span class="brown">推送(push)</span>操作</li></ul></li><li><ul><li>3.发送方的一个<span class="brown">计时器期限</span>到了，这时就把当前已有的缓存数据装入报文段(但长度不能超过MSS)发送出去</li></ul></li></ul><h4 id="_3-接收方糊涂窗口综合症" tabindex="-1">3.接收方糊涂窗口综合症 <a class="header-anchor" href="#_3-接收方糊涂窗口综合症" aria-label="Permalink to &quot;3.接收方糊涂窗口综合症&quot;">​</a></h4>',3)),i(e,{src:"/blog/images/study/ne/TCP接收方糊涂窗口综合症.png",title:"TCP接收方糊涂窗口综合症"}),l[11]||(l[11]=a("br",null,null,-1)),l[12]||(l[12]=a("ul",null,[a("li",null,"出现原因：接收方应用进程消耗数据太慢，例如每次只读取一个字节"),a("li",null,[s("解决方法：让接收方等待一段时间，使接收缓存已有足够的空间容纳"),a("span",{class:"green"},"一个最长的报文段"),s("，或者等到"),a("span",{class:"green"},"接收缓存已有一半空闲"),s("的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小")])],-1))])}const m=r(p,[["render",d]]);export{g as __pageData,m as default};
