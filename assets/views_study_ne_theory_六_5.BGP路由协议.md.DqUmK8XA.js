import{_ as n,C as s,c as P,o,b1 as t,G as i,j as l,a as r}from"./chunks/framework.BbzeyoJx.js";const c=JSON.parse('{"title":"六.5.BGP路由协议","description":"","frontmatter":{},"headers":[],"relativePath":"views/study/ne/theory/六/5.BGP路由协议.md","filePath":"views/study/ne/theory/六/5.BGP路由协议.md","lastUpdated":1758878470000}'),p={name:"views/study/ne/theory/六/5.BGP路由协议.md"};function G(d,a,B,u,b,h){const e=s("ImageViewer");return o(),P("div",null,[a[0]||(a[0]=t('<h1 id="六-5-bgp路由协议" tabindex="-1">六.5.BGP路由协议 <a class="header-anchor" href="#六-5-bgp路由协议" aria-label="Permalink to &quot;六.5.BGP路由协议&quot;">​</a></h1><h3 id="_1-简介" tabindex="-1">1.简介 <a class="header-anchor" href="#_1-简介" aria-label="Permalink to &quot;1.简介&quot;">​</a></h3><ul><li>边界网关协议BGP(Border Gateway Protocol)是一种实现<span class="brown">自治系统AS之间</span>的路由可达，并选择优选路由的<span class="brown">路径向量</span>路由协议</li><li>BGP提供了丰富的路由策略，能够灵活的进行<span class="brown">路由选路</span>，并且能指导邻居按策略发布路由</li><li>BGP使用TCP作为其传输层协议(端口号为<span class="green">179</span>)，并支持BGP与BFD联动、BGP Tracking等，提高了网络的可靠性</li><li>BGP属于EGP(内部)，RIP、OSPF、IS-IS属于IGP(外部)</li></ul><h4 id="_1-自治系统as-autonomous-system" tabindex="-1">1.自治系统AS(Autonomous System) <a class="header-anchor" href="#_1-自治系统as-autonomous-system" aria-label="Permalink to &quot;1.自治系统AS(Autonomous System)&quot;">​</a></h4><ul><li>AS是指在<span class="brown">一个实体管辖下</span>的拥有相同选路策略的IP网络。BGP网络中的每个AS都被分配一个唯一的AS号，用于区分不同的AS</li><li>AS号分为2字节AS号和4字节AS号</li><li><ul><li>2字节AS号的范围为<span class="green">1至65535</span></li></ul></li><li><ul><li>4字节AS号的范围为1至4294967295，支持4字节AS号的设备能够与支持2字节AS号的设备兼容</li></ul></li></ul><h4 id="_2-bgp邻居类型" tabindex="-1">2.BGP邻居类型 <a class="header-anchor" href="#_2-bgp邻居类型" aria-label="Permalink to &quot;2.BGP邻居类型&quot;">​</a></h4><p>BGP邻居类型按照运行方式分为<span class="green">EBGP(External BGP)</span>和<span class="green">IBGP(Internal BGP)</span></p><ul><li><span class="brown">EBGP</span>：运行于<span class="brown">不同AS之间</span>的BGP称为EBGP。为了防止AS间产生环路，当BGP设备接收EBGP对等体发送的路由时，会将带有本地AS号的路由丢弃</li><li><span class="brown">IBGP</span>：运行于<span class="brown">同一AS内部</span>的BGP称为IBGP。为了防止AS内部产生环路，BGP设备不将从IBGP对等体学到的路由通告给其他IBGP对等体(<span class="brown">水平分割原则</span>)，并与所有IBGP对等体建立全连接。为了解决IBGP对等体的连接数量太多的问题，BGP设计了路由反射器和BGP联盟</li></ul>',8)),i(e,{src:"/blog/images/study/ne/BGP邻居类型.png",title:"BGP邻居类型"}),a[1]||(a[1]=t('<br><h4 id="_3-bgp的路由器号-router-id" tabindex="-1">3.BGP的路由器号(Router ID) <a class="header-anchor" href="#_3-bgp的路由器号-router-id" aria-label="Permalink to &quot;3.BGP的路由器号(Router ID)&quot;">​</a></h4><ul><li>BGP的Router ID是一个用于标识BGP设备的<span class="brown">32位值</span>，通常是IPv4地址的形式，在BGP会话建立时发送的Open报文中携带。对等体之间建立BGP会话时，每个BGP设备都必须有唯一的Router ID，否则对等体之间不能建立BGP连接</li><li>BGP的Router ID可以采用<span class="brown">手工配置</span>，也可以让设备<span class="brown">自动选取</span>。</li><li><ul><li>缺省情况下，BGP选择设备上的Loopback接口的IPv4地址作为BGP的Router ID。</li></ul></li><li><ul><li>如果设备上没有配置Loopback接口，系统会选择接口中最大的IPv4地址作为BGP的Router ID。</li></ul></li><li><ul><li>一旦选出Router ID，除非发生接口地址删除等事件，否则即使配置了更大的地址，也保持原来的Router ID(<span class="brown">不抢占</span>)</li></ul></li><li>在华为设备中，会优先选择全局Router ID(最先配置的接口地址)，其次才是Loopback接口的IPv4地址</li></ul><h3 id="_2-bgp工作原理" tabindex="-1">2.BGP工作原理 <a class="header-anchor" href="#_2-bgp工作原理" aria-label="Permalink to &quot;2.BGP工作原理&quot;">​</a></h3><p>BGP对等体的建立、更新和删除等交互过程主要有<span class="brown">5种报文、6种状态机和5个原则</span></p><h4 id="_1-bgp的5种报文" tabindex="-1">1.BGP的5种报文 <a class="header-anchor" href="#_1-bgp的5种报文" aria-label="Permalink to &quot;1.BGP的5种报文&quot;">​</a></h4><p>BGP对等体间通过以下5种报文进行交互，其中Keepalive报文为<span class="green">周期性</span>发送，其余报文为<span class="green">触发式</span>发送</p><ul><li>Open报文：用于建立BGP对等体连接</li><li>Update报文：用于在对等体之间交换路由信息</li><li>Notification报文：用于中断BGP连接</li><li>Keepalive报文：用于保持BGP连接</li><li>Route-refresh报文：用于在改变路由策略后请求对等体重新发送路由信息。只有支持路由刷新(Route-refresh)能力的BGP设备会发送和响应此报文</li></ul><h4 id="_2-bgp的6种状态机" tabindex="-1">2.BGP的6种状态机 <a class="header-anchor" href="#_2-bgp的6种状态机" aria-label="Permalink to &quot;2.BGP的6种状态机&quot;">​</a></h4><ul><li>1.空闲(Idle)</li><li>2.连接(Connet)</li><li>3.活跃(Active)</li><li>4.Open报文已发送(OpenSent)</li><li>5.Open报文已确认(OpenConfirm)</li><li>6.连接已建立(Established)</li></ul><p>在BGP对等体建立的过程中，通常可见的3个状态是：空闲(Idle)、活跃(Active)和连接已建立(Established)</p>',11)),i(e,{src:"/blog/images/study/ne/BGP状态机.png",title:"BGP状态机"}),a[2]||(a[2]=t('<br><h4 id="_3-bgp的5个原则" tabindex="-1">3.BGP的5个原则 <a class="header-anchor" href="#_3-bgp的5个原则" aria-label="Permalink to &quot;3.BGP的5个原则&quot;">​</a></h4><ul><li>1.从IBGP对等体获得的BGP路由，BGP设备只发布给它的EBGP对等体</li><li>2.从EBGP对等体获得的BGP路由，BGP设备发布给它所有EBGP和IBGP对等体</li><li><ul><li><span class="green">ii不转，其他都转</span></li></ul></li><li>3.当存在多条到达同一目的地址的有效路由时，BGP设备只将<span class="green">最优路由</span>发布给对等体</li><li>4.路由更新时，BGP设备只发送更新的BGP路由</li><li><ul><li><span class="green">增量更新</span></li></ul></li><li>5.BGP同步规则：当一台路由器从自己的IBGP对等体学习到一条BGP路由时(这类路由被称为IBGP路由)，它将不能使用该条路由或把这条路由通告给自己的EBGP对等体，触发它又从IGP协议(例如OSPF等，此处也包含静态路由)学习到这条路由，也就是要求IBGP路由与IGP路由同步</li><li><ul><li>同步规则主要用于规则<span class="green">BGP路由黑洞问题</span>(同步规则默认关闭)</li></ul></li></ul><h3 id="_3-bgp和igp的交互" tabindex="-1">3.BGP和IGP的交互 <a class="header-anchor" href="#_3-bgp和igp的交互" aria-label="Permalink to &quot;3.BGP和IGP的交互&quot;">​</a></h3><h4 id="_1-bgp引入igp路由" tabindex="-1">1.BGP引入IGP路由 <a class="header-anchor" href="#_1-bgp引入igp路由" aria-label="Permalink to &quot;1.BGP引入IGP路由&quot;">​</a></h4><ul><li>BGP协议本身不发现路由，因此需要将其他路由引入到BGP路由表，实现AS间的路由互通。BGP引入路由时支持Import和Network两种方式</li><li>Import方式是按协议类型，将RIP、OSPF、IS-IS等协议的路由引入到BGP路由表中。为了保证引入的IGP路由的有效性，Import方式还可以引入静态路由和直连路由</li><li>Network方式是逐条将IP路由表中已经存在的路由引入到BGP路由表中，比Import方式更精确</li></ul><h4 id="_2-igp引入bgp路由" tabindex="-1">2.IGP引入BGP路由 <a class="header-anchor" href="#_2-igp引入bgp路由" aria-label="Permalink to &quot;2.IGP引入BGP路由&quot;">​</a></h4><ul><li>当一个AS需要引入其他AS的路由时，AS边缘路由器会在IGP路由表中引入BGP的路由。为了避免大量BGP路由对AS内设备造成影响，当IGP引入BGP路由时，可以使用路由策略，进行路由过滤和路由属性设置</li></ul><h3 id="_4-bgp的路由优先规则" tabindex="-1">4.BGP的路由优先规则 <a class="header-anchor" href="#_4-bgp的路由优先规则" aria-label="Permalink to &quot;4.BGP的路由优先规则&quot;">​</a></h3><p>在BGP路由表中，到达同一目的地可能存在多条路由。此时BGP会选择其中一条路由作为优选路由，并只把此路由发送给其对等体。BGP为了选出<span class="green">优选路由</span>，会根据BGP的路由优选规则依次比较这些<span class="brown">路由的BGP属性</span></p><h4 id="_1-bgp路由属性" tabindex="-1">1.BGP路由属性 <a class="header-anchor" href="#_1-bgp路由属性" aria-label="Permalink to &quot;1.BGP路由属性&quot;">​</a></h4><ul><li>1.<span class="brown">公认必须遵循(Well-known mandatory)</span>：所有BGP设备都可以识别此类属性，且必须存在于Update报文中，如果缺少这类属性，路由信息就会出错</li><li>2.<span class="brown">公认任意(Well-known discretionary)</span>：所有BGP设备都可以识别此类属性，但不要求必须存在于Update报文中，即就算缺少这类属性，路由信息也不会出错</li><li>3.<span class="brown">可选过渡(Optional transitive)</span>：BGP设备可以不识别此类属性，如果BGP设备不识别此类属性，但它仍然会接收这类属性，并通告给其他对等体</li><li>4.<span class="brown">可选非过渡(Optional non-transitive)</span>：BGP设备可以不识别此类属性，如果BGP设备不识别此类属性，则会被忽略该属性，且不会通告给其他对等体</li></ul><h4 id="_2-bgp常见属性类型" tabindex="-1">2.BGP常见属性类型 <a class="header-anchor" href="#_2-bgp常见属性类型" aria-label="Permalink to &quot;2.BGP常见属性类型&quot;">​</a></h4><table tabindex="0"><thead><tr><th>属性名</th><th>类型</th></tr></thead><tbody><tr><td>Origin 属性</td><td>公认必须遵循</td></tr><tr><td>AS_Path 属性</td><td>公认必须遵循</td></tr><tr><td>Next_Hop 属性</td><td>公认必须遵循</td></tr><tr><td>Local_Pref 属性</td><td>公认任意</td></tr><tr><td>MED 属性</td><td>可选非过渡</td></tr><tr><td>团体 属性</td><td>可选过渡</td></tr><tr><td>Originator_ID 属性</td><td>可选过渡</td></tr><tr><td>Cluster_List 属性</td><td>可选过渡</td></tr></tbody></table><h5 id="_1-origin" tabindex="-1">1.Origin <a class="header-anchor" href="#_1-origin" aria-label="Permalink to &quot;1.Origin&quot;">​</a></h5><p>Origin属性用来定义路径信息的来源，标记一条路由是怎么成为BGP路由的，共有3种类型</p><ul><li><span class="brown">1.IGP</span>：具有最高的优先级。通过network命令注入到BGP路由表的路由，其Origin属性为IGP</li><li><span class="brown">2.EGP</span>：优先级次之。通过EGP得到的路由信息，其Origin属性为EGP</li><li><span class="brown">3.Incomplete</span>：优先级最低。通过其他方式学到的路由信息。比如BGP通过import-route命令引入的路由，其Origin属性为Incomplete</li></ul><h5 id="_2-as-path" tabindex="-1">2.AS_Path <a class="header-anchor" href="#_2-as-path" aria-label="Permalink to &quot;2.AS_Path&quot;">​</a></h5><p>AS_Path属性按矢量顺序记录了某条路由从本地到目的地址所要经过的所有AS编号<br><span class="green">1.传播自身引入的路由时：</span></p><ul><li>当BGP将这条路由通过到EBGP对等体时，便会在Update报文中创建一个<span class="brown">携带本地AS号</span>的AS_Path列表</li><li>当BGP将这条路由通告给IBGP对等体时，便会在Update报文中创建一个<span class="brown">空的AS_Path</span>列表</li></ul><p><span class="green">2.传播从其他BGP的Update报文中学习到的路由时</span></p><ul><li>当BGP将这条路由通告给EBGP对等体时，便会把<span class="brown">本地AS编号添加在AS_Path列表</span>的最前面(最左边)</li><li>当BGP将这条路由通告给IBGP对等体时，<span class="brown">不会改变</span>这条路由相关的AS_Path属性</li></ul><h5 id="_3-next-hop" tabindex="-1">3.Next_Hop <a class="header-anchor" href="#_3-next-hop" aria-label="Permalink to &quot;3.Next_Hop&quot;">​</a></h5><p>Next_Hop属性记录了路由的下一跳信息。BGP的下一跳属性和IGP的有所不同，不一定就是邻居设备的IP地址。通常情况下，Next_Hop属性遵循下面的规则：</p><ul><li>1.BGP Speaker在向EBGP对等体发布某条路由时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址</li><li>2.BGP Speaker将本地始发路由发布给IBGP对等体时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址</li><li>3.BGP Speaker在向IBGP对等体发布从EBGP对等体学来的路由时，并不改变该路由信息的下一跳属性(<span class="brown">通常会手工修改</span>)</li></ul><h5 id="_4-local-pref" tabindex="-1">4.Local_Pref <a class="header-anchor" href="#_4-local-pref" aria-label="Permalink to &quot;4.Local_Pref&quot;">​</a></h5><p>Local_Pref属性表面路由器的BGP优先级，用于判断<span class="brown">流量离开AS</span>时的优选路由。</p><ul><li>当BGP的设备通过不同的IBGP对等体得到目的地址相同但下一跳不同的多条路由时，将优先选择Local_Pref属性值较高的路由。</li><li>Local_Pref属性仅在IBGP对等体之间有效，不通告给其他AS。</li><li>Local_Pref属性可以手动配置，如果路由没有配置Local_Pref属性，BGP选路时将该路由的Local_Pref值按缺省值100来处理</li></ul><h5 id="_5-med" tabindex="-1">5.MED <a class="header-anchor" href="#_5-med" aria-label="Permalink to &quot;5.MED&quot;">​</a></h5><p>MED(Multi-Exit Discriminator)属性用于判断<span class="brown">流量进入AS时</span>的优选路由，当一个运行BGP的设备通过不同的EBGP对等体得到目的地址相同但下一跳不同的多条路由时，在其他条件相同的情况下，将优先选择MED值较小者作为优选路由</p><ul><li>MED属性<span class="brown">仅在相邻两个AS之间</span>传递，收到此属性的AS一方不会再将其通告给任何其他第三方AS。</li><li>MED属性可以手动配置，如果路由没有配置MED属性，BGP选路是将该路由的MED值按缺省值0来处理</li></ul><h5 id="_6-团体" tabindex="-1">6.团体 <a class="header-anchor" href="#_6-团体" aria-label="Permalink to &quot;6.团体&quot;">​</a></h5><p>团体属性(Community)用于标识具有相同特征的BGP路由，使路由策略的应用更加灵活，同事降低了维护管理的难度。团体属性分为自定义团体属性和公认团体属性</p><table tabindex="0"><thead><tr><th>团体属性名称</th><th>团体属性号</th><th>说明</th></tr></thead><tbody><tr><td>Internet</td><td>0（0x00000000）</td><td>设备在收到具有此属性的路由后，可以向任何BGP对等体发送该路由。</td></tr><tr><td>No_Advertise</td><td>4294967042（0xFFFFFF02）</td><td>设备收到具有此属性的路由后，将不向任何BGP对等体发送该路由。</td></tr><tr><td>No_Export</td><td>4294967041（0xFFFFFF01）</td><td>设备收到具有此属性的路由后，将不向AS外发送该路由。</td></tr><tr><td>No_Export_Subconfed</td><td>4294967043（0xFFFFFF03）</td><td>设备收到具有此属性的路由后，将不向AS外发送该路由，也不向AS内其他子AS发布此路由。</td></tr></tbody></table><h5 id="preferred-value" tabindex="-1"><strong>Preferred-Value</strong> <a class="header-anchor" href="#preferred-value" aria-label="Permalink to &quot;**Preferred-Value**&quot;">​</a></h5><p>Preferred-Value(协议首选值)是华为设备的特有属性，该属性仅在本地有效。当BGP路由表中存在到相同目的地的路由时，将优先选择Preferred-Value值高的路由</p><ul><li>取值范围：0 ~ 65535；该值越大，则路由越优先</li><li>Preferred-Value只能在路由器本地配置，而且只影响本设备的路由优选。该属性不会传递任何BGP对等体</li></ul><h4 id="_3-bgp路由优选规则" tabindex="-1">3.BGP路由优选规则 <a class="header-anchor" href="#_3-bgp路由优选规则" aria-label="Permalink to &quot;3.BGP路由优选规则&quot;">​</a></h4><p>当到达同一目的网段存在多条路由时，BGP通过如下的次序进行路由优选： <br> 丢弃下一跳不可达的路由</p><ul><li>1.优选Preferred-Value属性值最大的路由</li><li>2.优选Local_Preference属性值最大的路由</li><li>3.本地始发的BGP路由优于从其他对等体学习到的路由</li><li><ul><li>本地始发的路由的优先级：优选手动聚合 &gt; 自动聚合 &gt; network &gt; import &gt; 从对等体学到的</li></ul></li><li>4.优选AS_Path属性值最短的路由</li><li>5.优选Origin属性最优的路由。Origin属性值按优先级从高到低的排列是：IGP、EGP及Incomplete</li><li>6.优选MED属性值最小的路由</li><li>7.优选从EBGP对等体学来的路由(EBGP路由优先级高于IBGP路由)</li><li>8.优选到Next_Hop的IGP度量值最小的路由</li><li>9.优选Cluster_List最短的路由</li><li>10.优选Router ID(Orginator_ID)最小的设备通告的路由</li><li>11.优选具有最小IP地址得对等体通告的路由</li></ul><div class="green"><p>第1和第2条，取值越大越优</p><p>后8条属性全部相同时，可以形成路由负载分担，取值越小越优</p></div><h3 id="_5-bgp路由反射器" tabindex="-1">5.BGP路由反射器 <a class="header-anchor" href="#_5-bgp路由反射器" aria-label="Permalink to &quot;5.BGP路由反射器&quot;">​</a></h3><p>为保证IBGP对等体之间的连通性，需要在IBGP对等体之间建立全连接关系。当设备数目很多时，设备配置将十分复杂，在IBGP对等体间使用路由反射器可以解决该问题。</p><ul><li><span class="green">路由反射器RR(Route Reflector)</span>：允许把从IBGP对等体学到的路由反射到其他IBGP对等体的BGP设备，类似OSPF网络中的DR</li><li><span class="green">客户机(Client)</span>：与RR形成反射邻居关系的IBGP设备</li><li><span class="green">非客户机(Non-Client)</span>：既不是RR也不是客户机的IBGP设备</li><li><span class="green">始发者(Originator)</span>：在AS内部始发路由的设备。Originator_ID属性用于防止集群内产生路由环路</li><li><span class="green">集群(Cluster)</span>：路由反射器及其客户机的集合。Cluster_List属性用于防止集群间产生路由环路</li></ul>',44)),i(e,{src:"/blog/images/study/ne/BGP路由反射器.png",title:"BGP路由反射器"}),a[3]||(a[3]=t('<br><h4 id="_1-路由反射器原理" tabindex="-1">1.路由反射器原理 <a class="header-anchor" href="#_1-路由反射器原理" aria-label="Permalink to &quot;1.路由反射器原理&quot;">​</a></h4><p>RR突破了&quot;<span class="green">从IBGP对等体获得的BGP路由，BGP设备只发布给它的EBGP对等体</span>&quot;的限制，并采用独有的Cluster_List属性和Originator_ID属性防止路由环路。RR从IBGP邻居发布路由规则如下：</p><ul><li>1.从非客户机学到的路由，发布给<span class="brown">所有客户机</span></li><li>2.从客户机学到的路由，发布给所有<span class="brown">非客户机和客户机(发起此路由的客户机除外)</span></li><li>3.从EBGP对等体学到的路由，发布给所有的<span class="brown">非客户机和客户机</span></li></ul><div class="green"> 口诀：非非不转，其他都转 </div>',5)),i(e,{src:"/blog/images/study/ne/BGP路由反射器.png",title:"BGP路由反射器"}),a[4]||(a[4]=l("br",null,null,-1)),a[5]||(a[5]=l("h4",{id:"_2-多集群路由反射器",tabindex:"-1"},[r("2.多集群路由反射器 "),l("a",{class:"header-anchor",href:"#_2-多集群路由反射器","aria-label":'Permalink to "2.多集群路由反射器"'},"​")],-1)),a[6]||(a[6]=l("p",null,"一个AS中可以存在多个集群，各个集群的RR之间建立IBGP对等体。当RR所处的网络层不同时，可以将较低网络层次的RR配成客户机，形成分级RR。当RR所处的网络层相同时，可以将不同的集群的RR全连接，形成同级RR",-1)),i(e,{src:"/blog/images/study/ne/BGP多集群路由反射器.png",title:"BGP多集群路由反射器"}),a[7]||(a[7]=l("br",null,null,-1)),a[8]||(a[8]=l("h3",{id:"_6-bgp联盟",tabindex:"-1"},[r("6.BGP联盟 "),l("a",{class:"header-anchor",href:"#_6-bgp联盟","aria-label":'Permalink to "6.BGP联盟"'},"​")],-1)),a[9]||(a[9]=l("p",null,"解决AS内部的IBGP网络连接激增问题，除了使用路由反射器之外，还可以使用联盟(Confederation)。",-1)),a[10]||(a[10]=l("ul",null,[l("li",null,"联盟将一个AS划分为若干个子AS。"),l("li",null,"每个子AS内部建立IBGP全连接关系，子AS之间建立联盟EBGP连接关系"),l("li",null,"但联盟外部AS扔认为整个联盟是一个AS")],-1)),i(e,{src:"/blog/images/study/ne/BGP联盟.png",title:"BGP联盟"}),a[11]||(a[11]=t('<br><h3 id="_7-路由聚合" tabindex="-1">7.路由聚合 <a class="header-anchor" href="#_7-路由聚合" aria-label="Permalink to &quot;7.路由聚合&quot;">​</a></h3><ul><li>路由聚合是将多条路由合并的机制，它通过只向对等体发送聚合后的路由而不发送所有的具体路由的方法，减小路由表的规模。并且被聚合饿路由如果发生路由振荡，也不再对网络造成影响，从而提高了网络的稳定性</li><li>BGP在IPv4网络中支持自动聚合和手动聚合两种方式，而IPv6网络中仅支持手动聚合方式</li><li><ul><li><span class="green">自动聚合</span>：对BGP引入的路由进行聚合。配置自动聚合后，BGP将按照自然网段聚合路由(例如非自然网段A类地址10.1.1.1/24和10.2.1.1/24将聚合为自然网段A类地址10.0.0.0/8)，并且BGP向对等体只发送聚合后的路由</li></ul></li><li><ul><li><span class="green">手动聚合</span>：对BGP本地路由表中存在的路由进行聚合。手动聚合可以控制聚合路由的属性，以及决定是否发布具体的路由</li></ul></li><li>为了避免路由聚合可能引起的路由环路，BGP设计了<span class="brown">AS_Set</span>属性。</li><li><ul><li>AS_Set属性是一种无序的AS_Path属性，标明聚合路由所经过的AS号。</li></ul></li><li><ul><li>当聚合路由重新进入AS_Set属性中列出的任何一个AS时，BGP将会检测到自己的AS号在聚合路由的AS_Set属性中，于是会聚合丢弃该聚合路由，从而避免了路由环路的形成</li></ul></li></ul>',3))])}const g=n(p,[["render",G]]);export{c as __pageData,g as default};
