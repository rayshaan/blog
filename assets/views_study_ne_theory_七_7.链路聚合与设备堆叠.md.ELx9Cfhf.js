import{_ as e,C as r,c as h,o as d,j as s,G as t,b1 as n,a as l}from"./chunks/framework.w2ptJf3g.js";const y=JSON.parse('{"title":"七.7.链路聚合与设备堆叠","description":"","frontmatter":{},"headers":[],"relativePath":"views/study/ne/theory/七/7.链路聚合与设备堆叠.md","filePath":"views/study/ne/theory/七/7.链路聚合与设备堆叠.md","lastUpdated":1752226003000}'),p={name:"views/study/ne/theory/七/7.链路聚合与设备堆叠.md"};function k(o,a,u,g,b,E){const i=r("ImageViewer");return d(),h("div",null,[a[0]||(a[0]=s("h1",{id:"七-7-链路聚合与设备堆叠",tabindex:"-1"},[l("七.7.链路聚合与设备堆叠 "),s("a",{class:"header-anchor",href:"#七-7-链路聚合与设备堆叠","aria-label":'Permalink to "七.7.链路聚合与设备堆叠"'},"​")],-1)),a[1]||(a[1]=s("h3",{id:"_1-eth-trunk",tabindex:"-1"},[l("1.Eth-Trunk "),s("a",{class:"header-anchor",href:"#_1-eth-trunk","aria-label":'Permalink to "1.Eth-Trunk"'},"​")],-1)),t(i,{src:"/blog/images/study/ne/Eth-Trunk.png"}),a[2]||(a[2]=n('<br><ul><li>Eth-Trunk是一种将多个以太网接口捆绑成一个逻辑接口的捆绑技术</li><li>Eth-Trunk链路聚合模式：<span class="brown">手工负载分担模式、LACP模式</span></li><li>Eth-Trunk可以用于二层的链路聚合，也可以用于三层的链路聚合</li><li><ul><li>缺省情况下，以太网接口工作在二层模式</li></ul></li><li>如果需要配置二层Eth-Trunk接口，可以通过<span class="green">portswitch</span>命令将该接口切成二层接口</li><li>如果需要配置三层Eth-Trunk接口，可以通过<span class="green">undo portswitch</span>命令将该接口切换成三层接口</li></ul><h4 id="_1-eth-trunk链路聚合模式" tabindex="-1">1.Eth-Trunk链路聚合模式 <a class="header-anchor" href="#_1-eth-trunk链路聚合模式" aria-label="Permalink to &quot;1.Eth-Trunk链路聚合模式&quot;">​</a></h4><h5 id="手工负载分担模式" tabindex="-1">手工负载分担模式 <a class="header-anchor" href="#手工负载分担模式" aria-label="Permalink to &quot;手工负载分担模式&quot;">​</a></h5><ul><li>当两台设备中有一台不支持LACP协议时，可以使用手工负载分担模式的Eth-Trunk来增加设备间的带宽及可靠性</li><li>在手工负载分担模式下，加入Eth-Trunk的链路都进行数据的转发</li><li>不具备检测故障能力</li></ul>',5)),t(i,{src:"/blog/images/study/ne/Eth-Trunk手工负载分担模式.png"}),a[3]||(a[3]=s("br",null,null,-1)),a[4]||(a[4]=s("h5",{id:"lacp模式-802-3ad",tabindex:"-1"},[l("LACP模式(802.3ad) "),s("a",{class:"header-anchor",href:"#lacp模式-802-3ad","aria-label":'Permalink to "LACP模式(802.3ad)"'},"​")],-1)),a[5]||(a[5]=s("ul",null,[s("li",null,[l("LACP模式也成为"),s("span",{class:"brown"},"M:N模式"),l("，其中M条链路处于活动状态转发数据，N条链路处于非活动状态作为备份链路")]),s("li",null,"下图中设置的活跃链路数为2，即2条链路处于转发状态，1条链路处于备份状态，不转发数据，只有当活跃的链路出现故障时，备份链路才进行转发")],-1)),t(i,{src:"/blog/images/study/ne/Eth-TrunkLACP模式.png"}),a[6]||(a[6]=s("br",null,null,-1)),a[7]||(a[7]=s("h6",{id:"工作模式-活动链路的选取规则",tabindex:"-1"},[l("工作模式(活动链路的选取规则) "),s("a",{class:"header-anchor",href:"#工作模式-活动链路的选取规则","aria-label":'Permalink to "工作模式(活动链路的选取规则)"'},"​")],-1)),t(i,{src:"/blog/images/study/ne/LACP工作模式.png"}),a[8]||(a[8]=n('<br><p><span class="green">主动端：</span></p><ul><li>先比<span class="brown">系统优先级</span>，再比<span class="brown">MAC地址</span>，值越小越优</li><li>系统LACP优先级的(默认)值为<span class="green">32768</span></li></ul><p><span class="green">活动链路：</span></p><ul><li>从主动端，先比<span class="brown">接口优先级</span>，再比<span class="brown">接口编号</span>，值越小越优</li><li>接口LACP优先级的(默认)值为<span class="green">32768</span></li></ul><h6 id="抢占机制" tabindex="-1">抢占机制 <a class="header-anchor" href="#抢占机制" aria-label="Permalink to &quot;抢占机制&quot;">​</a></h6>',6)),t(i,{src:"/blog/images/study/ne/LACP抢占机制.png"}),a[9]||(a[9]=n('<br><p>执行命令lacp preempt enable使用抢占功能，默认是关闭状态</p><h4 id="_4-eth-trunk接口负载分担" tabindex="-1">4.Eth-Trunk接口负载分担 <a class="header-anchor" href="#_4-eth-trunk接口负载分担" aria-label="Permalink to &quot;4.Eth-Trunk接口负载分担&quot;">​</a></h4><ul><li>Eth-Trunk接口进行负载分担时，可以选择IP地址或者包作为负载分担的散列依据。同事还可以设置成员接口的负载分担权重</li><li>Eth-Trunk接口中，某成员接口的权重值占所有成员接口负载分担权重之和的比例越大，该成员接口承担的负载就越大</li></ul><table tabindex="0"><thead><tr><th style="text-align:left;">接口负载分担</th><th style="text-align:left;">特点</th></tr></thead><tbody><tr><td style="text-align:left;">逐流负载分担</td><td style="text-align:left;">当报文的源IP地址、目的IP地址都相同或者报文的源MAC地址、目的地址都相同时，这些报文从同一条成员链路上通过</td></tr><tr><td style="text-align:left;">逐包负载分担</td><td style="text-align:left;">以报文为单位分别从不同的成员链路上发送</td></tr></tbody></table><h4 id="_5-eth-trunk接口配置流程" tabindex="-1">5.Eth-Trunk接口配置流程 <a class="header-anchor" href="#_5-eth-trunk接口配置流程" aria-label="Permalink to &quot;5.Eth-Trunk接口配置流程&quot;">​</a></h4>',6)),t(i,{src:"/blog/images/study/ne/Eth-Trunk接口配置流程.png"}),a[10]||(a[10]=n(`<br><h5 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h5><p>1.创建Eth-Trunk接口并配置地址</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Eth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Trunk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 0 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//创建Eth-Trunk接口</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">undo</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> portswitch</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 创建三层接口</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mode</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lacp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">static</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 模式选为lacp模式</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ip</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> address</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 192.168.1.254 255.255.255.0 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 配置ip地址</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trunkport</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GigabitEthernet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 0/0/0 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 通过trunkport命令将物理接口拉入</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trunkport</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GigabitEthernet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 0/0/1</span></span></code></pre></div><p>2.将物理接口添加入Eth-Trunk中</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 进入物理接口中，将其推入Eth-Trunk接口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GigabitEthernet0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/0/0 </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">eth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trunk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GigabitEthernet0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/0/1 </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">eth</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">-</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">trunk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 0</span></span></code></pre></div><h3 id="_2-设备堆叠、集群" tabindex="-1">2.设备堆叠、集群 <a class="header-anchor" href="#_2-设备堆叠、集群" aria-label="Permalink to &quot;2.设备堆叠、集群&quot;">​</a></h3>`,7)),t(i,{src:"/blog/images/study/ne/设备堆叠与集群.png"}),a[11]||(a[11]=n('<br><ul><li>堆叠(iStack)，将多台支持堆叠特性的交换机通过堆叠线缆连接在一起，从逻辑上虚拟成一台交换设备</li><li>集群(Cluster Switch System，CSS)，将两台支持集群特性的交换机设备组合在一起，从逻辑上虚拟成一台交换设备</li><li>集群只支持两台设备，一般<span class="green">高端框式交换机支持CSS</span>、<span class="green">盒式设备支持iStack</span></li><li>通过使用堆叠、集群技术结合链路聚合技术可以简单构建高可靠、无环的园区网络</li></ul><h4 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h4><ul><li>1.可有效提高资源利用率，获得更高的转发性能、链路带宽</li><li>2.可以降低网络规划的复杂度，方便对于网络的管理</li><li>3.可以大大降低故障导致的业务中断时间</li></ul><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ul><li>1.堆叠是一种非标准化的技术，同一组堆叠交换机必须是同一品牌</li><li>2.后期设备版本升级比较麻烦</li><li>3.配置相对复杂，对管理员技能水平要求较高</li></ul><h3 id="_3-堆叠" tabindex="-1">3.堆叠 <a class="header-anchor" href="#_3-堆叠" aria-label="Permalink to &quot;3.堆叠&quot;">​</a></h3><h4 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h4><ul><li>堆叠系统中所有的单台交换机都称为成员交换机，按照功能不同，可以分为三种角色：</li><li><ul><li>主交换机(Master)：主交换机负责管理整个堆叠。堆叠系统中只有一台主交换机。</li></ul></li><li><ul><li>备交换机(Standby)：备交换机是主交换机的备份交换机。堆叠系统中只有一台备交换机。当主交换机故障时，备交换机会接替原主交换机的所有业务。</li></ul></li><li><ul><li>从交换机(Slave)：从交换机用于业务转发，堆叠系统中可以有多台从交换机。从交换机数量越多，堆叠系统的转发带宽越大。除主交换机和备交换机外，堆叠中其他所有的成员交换机都是从交换机。当备交换机不可用时，从交换机承担备交换机的角色。</li></ul></li><li>堆叠优先级：堆叠优先级是成员交换机的一个属性，主要用于角色选举过程中确定成员交换机的角色，优先级值越大表示优先级越高。优先级越高当选为主交换机的可能性越大。</li></ul>',9)),t(i,{src:"/blog/images/study/ne/堆叠基本概念.png"}),a[12]||(a[12]=s("br",null,null,-1)),a[13]||(a[13]=s("h4",{id:"堆叠方式",tabindex:"-1"},[l("堆叠方式 "),s("a",{class:"header-anchor",href:"#堆叠方式","aria-label":'Permalink to "堆叠方式"'},"​")],-1)),t(i,{src:"/blog/images/study/ne/堆叠方式.png"}),a[14]||(a[14]=s("br",null,null,-1)),a[15]||(a[15]=s("h4",{id:"堆叠管理与配置文件",tabindex:"-1"},[l("堆叠管理与配置文件 "),s("a",{class:"header-anchor",href:"#堆叠管理与配置文件","aria-label":'Permalink to "堆叠管理与配置文件"'},"​")],-1)),t(i,{src:"/blog/images/study/ne/堆叠管理与配置文件.png"}),a[16]||(a[16]=n('<br><h3 id="_4-m-lag" tabindex="-1">4.M-LAG <a class="header-anchor" href="#_4-m-lag" aria-label="Permalink to &quot;4.M-LAG&quot;">​</a></h3><ul><li>M-LAG(Multichassis Link Aggregation Group)即<span class="brown">跨设备链路聚合组</span>，是一种实现跨设备链路聚合的机制</li><li>如下图所示：M-LAG是将ServerA(可以是设备或主机)与两外两台设备DeviceA和DeviceB进行跨设备链路聚合，如同ServerA和一台设备建立了链路聚合关系，从而把链路可靠性从<span class="green">单板级</span>提高到了<span class="green">设备级</span></li></ul>',3)),t(i,{src:"/blog/images/study/ne/M-LAG.png"}),a[17]||(a[17]=n('<br><h4 id="堆叠与m-lag对比" tabindex="-1">堆叠与M-LAG对比 <a class="header-anchor" href="#堆叠与m-lag对比" aria-label="Permalink to &quot;堆叠与M-LAG对比&quot;">​</a></h4><table tabindex="0"><thead><tr><th>对比维度</th><th>堆叠</th><th>MLAG（推荐）</th></tr></thead><tbody><tr><td>可靠性</td><td>一般：控制面集中，可能故障在成员设备上扩散</td><td>更高：控制面独立，故障域隔离</td></tr><tr><td>配置复杂度</td><td>简单：逻辑上是一台设备</td><td>一般：两台设备需独立配置</td></tr><tr><td>成本</td><td>一般：需要部署堆叠线缆</td><td>一般：需要部署Peer-link连线</td></tr><tr><td>性能</td><td>一般：Master 控制面要控制所有堆叠成员的转发面，CPU 负载加重</td><td>高：成员设备独立转发，CPU 载荷保持不变</td></tr><tr><td>升级中断时间</td><td>相对较长：通过堆叠快速升级，典型配置单台设备业务中断时间在 20 秒~1 分钟左右；整网堆叠系统需前后方和，升级时间较长</td><td>短：每台设备可独立升级，流量秒级中断</td></tr><tr><td>网络设计</td><td>相对简单：逻辑上单节点设计</td><td>相对复杂：逻辑上双节点设计</td></tr><tr><td>适用场景</td><td>对软件版本升级中断时间无要求<br>维护简单</td><td>对软件版本升级时业务中断时间要求较高<br>可靠性需求高<br>可接受增加一定程度的维护复杂度</td></tr></tbody></table>',3))])}const T=e(p,[["render",k]]);export{y as __pageData,T as default};
