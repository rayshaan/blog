import{_ as r,C as i,c as o,o as d,a4 as t,G as n,j as l,a as s}from"./chunks/framework.C_GGjjHE.js";const m=JSON.parse('{"title":"六.2.RIP路由协议","description":"","frontmatter":{},"headers":[],"relativePath":"views/study/ne/theory/六/2.RIP路由协议.md","filePath":"views/study/ne/theory/六/2.RIP路由协议.md","lastUpdated":1755160894000}'),p={name:"views/study/ne/theory/六/2.RIP路由协议.md"};function P(b,a,I,u,g,R){const e=i("ImageViewer");return d(),o("div",null,[a[0]||(a[0]=t('<h1 id="六-2-rip路由协议" tabindex="-1">六.2.RIP路由协议 <a class="header-anchor" href="#六-2-rip路由协议" aria-label="Permalink to &quot;六.2.RIP路由协议&quot;">​</a></h1><h3 id="_1-常见的路由协议" tabindex="-1">1.常见的路由协议 <a class="header-anchor" href="#_1-常见的路由协议" aria-label="Permalink to &quot;1.常见的路由协议&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:center;">名称</th><th style="text-align:center;">协议分类(工作原理)</th><th style="text-align:center;">协议分类(工作区域)</th><th style="text-align:center;">路由算法</th></tr></thead><tbody><tr><td style="text-align:center;">RIP</td><td style="text-align:center;">距离矢量</td><td style="text-align:center;">IGP</td><td style="text-align:center;">Bellman-Ford</td></tr><tr><td style="text-align:center;">OSPF/IS-IS</td><td style="text-align:center;">链路状态</td><td style="text-align:center;">IGP</td><td style="text-align:center;">Dijkstra</td></tr><tr><td style="text-align:center;">BGP</td><td style="text-align:center;">路径向量</td><td style="text-align:center;">EGP</td><td style="text-align:center;">/</td></tr></tbody></table><h3 id="_2-ripv2的基本原理" tabindex="-1">2.RIPv2的基本原理 <a class="header-anchor" href="#_2-ripv2的基本原理" aria-label="Permalink to &quot;2.RIPv2的基本原理&quot;">​</a></h3><h4 id="_1-特性" tabindex="-1">1.特性 <a class="header-anchor" href="#_1-特性" aria-label="Permalink to &quot;1.特性&quot;">​</a></h4><p>RIP协议的特性：<br></p><ul><li>RIP协议(无论是RIPv1还是RIPv2)是基于<span class="green">UDP</span>的应用层协议，RIP对应的端口号是<span class="green">UDP 520</span></li><li>RIPv1属于<span class="brown">有类路由</span>协议，RIPv2属于<span class="brown">无类路由</span>协议</li><li>RIPv1封装的RIP消息，其目的地址也就是<span class="brown">255.255.255.255</span></li><li>RIPv2在发送RIP消息时，封装的目的IP地址为组播地址<span class="brown">224.0.0.9</span></li><li>RIPv1必须进行路由<span class="brown">自动汇总</span>，RIPv2可以<span class="brown">自动汇总、手动汇总、不汇总</span></li></ul><h4 id="_2-计时器" tabindex="-1">2.计时器 <a class="header-anchor" href="#_2-计时器" aria-label="Permalink to &quot;2.计时器&quot;">​</a></h4><p>RIP协议的计时器：<br></p><ul><li><span class="green">更新计时器(Update Timer)</span>：缺省值是<span class="brown">30s</span></li><li><span class="green">老化计时器(Age Timer)</span>：缺省值是<span class="brown">180s</span></li><li><span class="green">抑制时间(suppress)</span>：在这段时间内最佳路由信息的发布被抑制，华为固定为<span class="brown">0s</span></li><li><span class="green">垃圾收集计时器(Garbage Collection Timer)</span>：缺省值是<span class="brown">120s</span></li></ul><h4 id="_3-度量值" tabindex="-1">3.度量值 <a class="header-anchor" href="#_3-度量值" aria-label="Permalink to &quot;3.度量值&quot;">​</a></h4><p>RIP协议的度量值：<br></p><ul><li>RIP路由的度量值等于<span class="green">跳数</span></li><li>RIP规定最大度量值为<span class="green">15跳</span>(<span class="brown">16跳视为不可达</span>)</li></ul><h4 id="_4-数据格式" tabindex="-1">4.数据格式 <a class="header-anchor" href="#_4-数据格式" aria-label="Permalink to &quot;4.数据格式&quot;">​</a></h4><p>头部固定<span class="brown">4</span>个字节，一条路由条目<span class="brown">20</span>个字节，几个<span class="brown">计时器</span>参数<span class="brown">没有包含</span>在RIP的封装结构中：</p><ul><li><span class="green">1.命令</span>：设置为1时表示请求报文(Request)，设置为2时表示响应报文(Response)</li><li><span class="green">2.地址簇标识符</span>：标识这条路由的地址类型，如果地址为IP地址，则这个字段的值取2</li><li><span class="green">3.外部路由标记</span>：告诉接收方路由器，这条路由是通过RIP协议学习到的，还是通过其他路由协议学习到的</li></ul>',16)),n(e,{src:"/blog/images/study/ne/RIP的消息封装结构.png",title:"RIP的消息封装结构"}),a[1]||(a[1]=l("br",null,null,-1)),a[2]||(a[2]=l("h4",{id:"_5-工作过程",tabindex:"-1"},[s("5.工作过程 "),l("a",{class:"header-anchor",href:"#_5-工作过程","aria-label":'Permalink to "5.工作过程"'},"​")],-1)),n(e,{src:"/blog/images/study/ne/RIP工作过程.png",title:"RIP工作过程"}),a[3]||(a[3]=l("br",null,null,-1)),a[4]||(a[4]=l("h4",{id:"_6-响应过程",tabindex:"-1"},[s("6.响应过程 "),l("a",{class:"header-anchor",href:"#_6-响应过程","aria-label":'Permalink to "6.响应过程"'},"​")],-1)),n(e,{src:"/blog/images/study/ne/RIP响应过程.png",title:"RIP响应过程"}),a[5]||(a[5]=l("br",null,null,-1)),a[6]||(a[6]=l("h4",{id:"_7-响应完成",tabindex:"-1"},[s("7.响应完成 "),l("a",{class:"header-anchor",href:"#_7-响应完成","aria-label":'Permalink to "7.响应完成"'},"​")],-1)),n(e,{src:"/blog/images/study/ne/RIP更新路由表.png",title:"RIP更新路由表"}),a[7]||(a[7]=l("br",null,null,-1)),a[8]||(a[8]=l("h3",{id:"_3-路由环路隐患",tabindex:"-1"},[s("3.路由环路隐患 "),l("a",{class:"header-anchor",href:"#_3-路由环路隐患","aria-label":'Permalink to "3.路由环路隐患"'},"​")],-1)),n(e,{src:"/blog/images/study/ne/RIP路由环路隐患.png",title:"RIP路由环路隐患"}),a[9]||(a[9]=l("br",null,null,-1)),a[10]||(a[10]=l("h3",{id:"_4-路由环路隐患解决",tabindex:"-1"},[s("4.路由环路隐患解决 "),l("a",{class:"header-anchor",href:"#_4-路由环路隐患解决","aria-label":'Permalink to "4.路由环路隐患解决"'},"​")],-1)),a[11]||(a[11]=l("h4",{id:"_1-水平分割",tabindex:"-1"},[s("1.水平分割 "),l("a",{class:"header-anchor",href:"#_1-水平分割","aria-label":'Permalink to "1.水平分割"'},"​")],-1)),a[12]||(a[12]=l("ul",null,[l("li",null,"水平分割(Split Horizon)引入的规则是，禁止路由器将从一个接口学习到的路由，再从同一个接口通告出去")],-1)),n(e,{src:"/blog/images/study/ne/RIP路由环路水平分割.png",title:"RIP路由环路水平分割"}),a[13]||(a[13]=l("br",null,null,-1)),a[14]||(a[14]=l("h4",{id:"_2-毒性反转",tabindex:"-1"},[s("2.毒性反转 "),l("a",{class:"header-anchor",href:"#_2-毒性反转","aria-label":'Permalink to "2.毒性反转"'},"​")],-1)),a[15]||(a[15]=l("ul",null,[l("li",null,"毒性反转(Poison Reverse)引入的规则是，当路由器从一个接口学习到一条去往某个网络路由时，它就会通过这个接口通告一条该网络不可达的路由")],-1)),n(e,{src:"/blog/images/study/ne/RIP路由环路毒性反转.png",title:"RIP路由环路毒性反转"}),a[16]||(a[16]=l("br",null,null,-1)),a[17]||(a[17]=l("h4",{id:"_3-路由毒化和触发更新",tabindex:"-1"},[s("3.路由毒化和触发更新 "),l("a",{class:"header-anchor",href:"#_3-路由毒化和触发更新","aria-label":'Permalink to "3.路由毒化和触发更新"'},"​")],-1)),a[18]||(a[18]=l("ul",null,[l("li",null,"路由毒化(Route Poisoning)是指路由器会将自己路由表中已经失效的路由作为一条不可达路由主动通告出去"),l("li",null,"触发更新(Triggered Update)顾名思义，是指路由器在网络发生变化时，不等待更新计时器到时，就主动发送更新")],-1)),n(e,{src:"/blog/images/study/ne/RIP路由环路路由毒化和触发更新.png",title:"RIP路由环路路由毒化和触发更新"}),a[19]||(a[19]=l("br",null,null,-1)),a[20]||(a[20]=l("h3",{id:"_5-ripv2的基本配置",tabindex:"-1"},[s("5.RIPv2的基本配置 "),l("a",{class:"header-anchor",href:"#_5-ripv2的基本配置","aria-label":'Permalink to "5.RIPv2的基本配置"'},"​")],-1)),n(e,{src:"/blog/images/study/ne/RIPv2的基本配置.png",title:"RIPv2的基本配置"}),a[21]||(a[21]=l("br",null,null,-1)),a[22]||(a[22]=l("h3",{id:"_6-ripv2路由自动汇总",tabindex:"-1"},[s("6.RIPv2路由自动汇总 "),l("a",{class:"header-anchor",href:"#_6-ripv2路由自动汇总","aria-label":'Permalink to "6.RIPv2路由自动汇总"'},"​")],-1)),n(e,{src:"/blog/images/study/ne/RIPv2路由自动汇总.png",title:"RIPv2路由自动汇总"}),a[23]||(a[23]=t('<p>在华为设备上，以太网口和串口都默认启用了<span class="brown">水平分割</span>功能，RIPv2的自动汇总就会<span class="brown">失效</span>，要使RIPv2的默认自动汇总生效，有两种方法：</p><ul><li>1.使用<span class="green">summary always</span>命令，配置该命令后，不论水平分割是否启用，RIPv2的自动汇总都会生效</li><li>2.<span class="green">关闭</span>相应接口下的水平分割功能</li></ul><h3 id="_7-ripv2路由手动汇总" tabindex="-1">7.RIPv2路由手动汇总 <a class="header-anchor" href="#_7-ripv2路由手动汇总" aria-label="Permalink to &quot;7.RIPv2路由手动汇总&quot;">​</a></h3>',3)),n(e,{src:"/blog/images/study/ne/RIPv2路由手动汇总.png",title:"RIPv2路由手动汇总"}),a[24]||(a[24]=l("h3",{id:"_8-ripv2下发默认路由",tabindex:"-1"},[s("8.RIPv2下发默认路由 "),l("a",{class:"header-anchor",href:"#_8-ripv2下发默认路由","aria-label":'Permalink to "8.RIPv2下发默认路由"'},"​")],-1)),n(e,{src:"/blog/images/study/ne/RIPv2下发默认路由.png",title:"RIPv2下发默认路由"}),a[25]||(a[25]=l("h3",{id:"_9-ripv2认证",tabindex:"-1"},[s("9.RIPv2认证 "),l("a",{class:"header-anchor",href:"#_9-ripv2认证","aria-label":'Permalink to "9.RIPv2认证"'},"​")],-1)),n(e,{src:"/blog/images/study/ne/RIPv2认证.png",title:"RIPv2认证"})])}const v=r(p,[["render",P]]);export{m as __pageData,v as default};
