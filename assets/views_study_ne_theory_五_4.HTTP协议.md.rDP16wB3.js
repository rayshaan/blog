import{_ as s,C as n,c as T,o,j as l,G as e,b1 as r,a as i}from"./chunks/framework.w2ptJf3g.js";const m=JSON.parse('{"title":"五.4.HTTP协议","description":"","frontmatter":{},"headers":[],"relativePath":"views/study/ne/theory/五/4.HTTP协议.md","filePath":"views/study/ne/theory/五/4.HTTP协议.md","lastUpdated":1753949155000}'),d={name:"views/study/ne/theory/五/4.HTTP协议.md"};function p(h,t,P,u,b,_){const a=n("ImageViewer");return o(),T("div",null,[t[0]||(t[0]=l("h1",{id:"五-4-http协议",tabindex:"-1"},[i("五.4.HTTP协议 "),l("a",{class:"header-anchor",href:"#五-4-http协议","aria-label":'Permalink to "五.4.HTTP协议"'},"​")],-1)),t[1]||(t[1]=l("h3",{id:"_1-统一资源定位符url",tabindex:"-1"},[i("1.统一资源定位符URL "),l("a",{class:"header-anchor",href:"#_1-统一资源定位符url","aria-label":'Permalink to "1.统一资源定位符URL"'},"​")],-1)),t[2]||(t[2]=l("ul",null,[l("li",null,"是对互联网上资源的位置和访问方法的一种简洁表示"),l("li",null,"实际上就是在互联网上的资源的地址"),l("li",null,"格式：由以冒号(:)隔开的两大部分组成，对字符大小写没有要求")],-1)),e(a,{src:"/blog/images/study/ne/url.png",title:"url"}),t[3]||(t[3]=l("br",null,null,-1)),t[4]||(t[4]=l("h3",{id:"_2-使用http的url",tabindex:"-1"},[i("2.使用HTTP的URL "),l("a",{class:"header-anchor",href:"#_2-使用http的url","aria-label":'Permalink to "2.使用HTTP的URL"'},"​")],-1)),e(a,{src:"/blog/images/study/ne/使用HTTP的URL.png",title:"使用HTTP的URL"}),t[5]||(t[5]=r('<br><h3 id="_3-超文本传输协议http" tabindex="-1">3.超文本传输协议HTTP <a class="header-anchor" href="#_3-超文本传输协议http" aria-label="Permalink to &quot;3.超文本传输协议HTTP&quot;">​</a></h3><ul><li>HTTP协议本身是<span class="brown">无连接</span>的，即双方在交换HTTP报文之前不需要建立连接。HTTP使用了面向连接的<span class="green">TCP</span>作为传输层协议，默认端口为<span class="green">80/443</span></li><li>HTTP协议是<span class="brown">无状态</span>的，即服务器不会记录客户信息，客户端第二次访问同第一次访问获取的响应相同。HTTP无状态的特性简化了服务器的操作，使其更容易支持大量并发的HTTP请求</li></ul><h3 id="_4-http的操作过程" tabindex="-1">4.HTTP的操作过程 <a class="header-anchor" href="#_4-http的操作过程" aria-label="Permalink to &quot;4.HTTP的操作过程&quot;">​</a></h3>',4)),e(a,{src:"/blog/images/study/ne/HTTP的操作过程.png",title:"HTTP的操作过程"}),t[6]||(t[6]=l("br",null,null,-1)),t[7]||(t[7]=l("h3",{id:"_5-http协议不同版本的地点",tabindex:"-1"},[i("5.HTTP协议不同版本的地点 "),l("a",{class:"header-anchor",href:"#_5-http协议不同版本的地点","aria-label":'Permalink to "5.HTTP协议不同版本的地点"'},"​")],-1)),t[8]||(t[8]=l("h4",{id:"http-1-0",tabindex:"-1"},[i("HTTP/1.0 "),l("a",{class:"header-anchor",href:"#http-1-0","aria-label":'Permalink to "HTTP/1.0"'},"​")],-1)),t[9]||(t[9]=l("ul",null,[l("li",null,"每请求一个文档就要有两倍的RTT开销"),l("li",null,"客户和服务器每一次建立新的TCP连接都要分配缓存和变量"),l("li",null,"这种非持续连接会使加重服务器的负担")],-1)),e(a,{src:"/blog/images/study/ne/HTTP1.0.png",title:"HTTP1.0"}),t[10]||(t[10]=r('<br><h4 id="http-1-1" tabindex="-1">HTTP/1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;HTTP/1.1&quot;">​</a></h4><ul><li><span class="green">持续连接(persistent connection)</span>：服务器在发送响应后仍然在一段时间内<span class="brown">保持</span>这条连接(不释放)，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文</li><li>只要文档都在同一个服务器上，就可以继续使用该TCP连接</li><li>两种工作方式：</li><li><ul><li><span class="brown">非流水线方式(without pipelining)</span></li></ul></li><li><ul><li><span class="brown">流水线方式(with pipelining)</span></li></ul></li></ul><h5 id="非流水线方式" tabindex="-1">非流水线方式 <a class="header-anchor" href="#非流水线方式" aria-label="Permalink to &quot;非流水线方式&quot;">​</a></h5><ul><li>客户在收到前一个响应之后才能发出下一个请求</li><li>缺点：TCP连接空闲状态</li></ul>',5)),e(a,{src:"/blog/images/study/ne/HTTP非流水线方式.png",title:"HTTP非流水线方式"}),t[11]||(t[11]=l("br",null,null,-1)),t[12]||(t[12]=l("h5",{id:"流水线方式",tabindex:"-1"},[i("流水线方式 "),l("a",{class:"header-anchor",href:"#流水线方式","aria-label":'Permalink to "流水线方式"'},"​")],-1)),t[13]||(t[13]=l("ul",null,[l("li",null,"客户在收到响应报文之前就能够接着发送新的请求报文"),l("li",null,"连续的多个请求报文到达服务器后，服务器就可以连续发回响应报文"),l("li",null,"下载效率高")],-1)),e(a,{src:"/blog/images/study/ne/HTTP流水线方式.png",title:"HTTP流水线方式"}),t[14]||(t[14]=r('<br><h4 id="https" tabindex="-1">HTTPS <a class="header-anchor" href="#https" aria-label="Permalink to &quot;HTTPS&quot;">​</a></h4><ul><li>使用<span class="green">TCP</span>连接，默认端口<span class="green">443</span></li><li>使用<span class="green">SSL/TLS</span>来加密数据报</li><li>提供对网站服务器的<span class="brown">身份认证</span>，保护交换数据的<span class="brown">私密性与完整性</span></li><li>比HTTP<span class="brown">更安全</span>，但比HTTP<span class="brown">传输效率要低</span></li></ul><h4 id="http-2" tabindex="-1">HTTP/2 <a class="header-anchor" href="#http-2" aria-label="Permalink to &quot;HTTP/2&quot;">​</a></h4><ul><li>二进制分帧(Binary Format)</li><li>头部压缩(MulHeader Compression)</li><li>服务器推送(server push)</li><li>多路复用(Multiplexing)，允许客户端复用TCP连接进行多个请求</li></ul><h4 id="http-3" tabindex="-1">HTTP/3 <a class="header-anchor" href="#http-3" aria-label="Permalink to &quot;HTTP/3&quot;">​</a></h4><ul><li>基于<span class="green">QUIC</span>协议，QUIC是一个基于<span class="brown">UDP</span>的可靠传输协议</li><li>避免队头阻塞</li><li>快速建立连接</li><li>内置加密</li><li>更好的拥塞控制</li></ul><h3 id="_6-代理服务器" tabindex="-1">6.代理服务器 <a class="header-anchor" href="#_6-代理服务器" aria-label="Permalink to &quot;6.代理服务器&quot;">​</a></h3><ul><li><span class="green">代理服务器(proxy server)</span>又称为<span class="brown">万维网高速缓存(Web cache)</span>，它代表浏览器发出HTTP请求</li><li>使用高速缓存可<span class="brown">减少</span>访问互联网服务器的<span class="brown">时延</span></li></ul>',9)),e(a,{src:"/blog/images/study/ne/HTTP代理服务器.png",title:"HTTP代理服务器"}),t[15]||(t[15]=r('<br><h3 id="_7-http请求报文方法" tabindex="-1">7.HTTP请求报文方法 <a class="header-anchor" href="#_7-http请求报文方法" aria-label="Permalink to &quot;7.HTTP请求报文方法&quot;">​</a></h3><table tabindex="0"><thead><tr><th>方法(操作)</th><th>意义(作用)</th></tr></thead><tbody><tr><td>OPTION</td><td>请求一些选项的信息</td></tr><tr><td>GET</td><td>请求读取由URL所标志的信息</td></tr><tr><td>HEAD</td><td>请求读取由URL所标志的信息的首部</td></tr><tr><td>POST</td><td>给服务器添加信息</td></tr><tr><td>PUT</td><td>在指明的URL下储存一个文档</td></tr><tr><td>DELETE</td><td>删除指明的URL所标志的资源</td></tr><tr><td>TRACE</td><td>用来进行环回测试的请求报文</td></tr><tr><td>CONNECT</td><td>用于代理服务器</td></tr></tbody></table><h3 id="_8-http状态码" tabindex="-1">8.HTTP状态码 <a class="header-anchor" href="#_8-http状态码" aria-label="Permalink to &quot;8.HTTP状态码&quot;">​</a></h3><ul><li>1xx表示通知信息：如请求收到了或正在进行处理</li><li>2xx表示成功，如接受或知道了</li><li>3xx表示重定向：表示要完成请求还必须采取进一步的行动</li><li>4xx表示客户的差错：如请求中有错误的语法或不能完成</li><li>5xx表示服务器的差错：如服务器无效无法完成请求</li></ul><p>响应报文中常见的三种状态：<br></p><ul><li>HTTP/1.1 202 Accepted 接受</li><li>HTTP/1.1 400 Bad Request 错误的请求</li><li>HTTP/1.1 403 Forbidden 资源被禁止</li><li>HTTP/1.1 404 Not Found 资源未找到</li><li>HTTP/1.1 500 Internal Server Error 表示服务器内部错误</li></ul><h3 id="_9-cookie和session" tabindex="-1">9.Cookie和Session <a class="header-anchor" href="#_9-cookie和session" aria-label="Permalink to &quot;9.Cookie和Session&quot;">​</a></h3>',8)),e(a,{src:"/blog/images/study/ne/Cookie和Session.png",title:"Cookie和Session"}),t[16]||(t[16]=r('<br><p>区别<br></p><table tabindex="0"><thead><tr><th></th><th>作用</th><th>保存位置</th><th>保存时间</th></tr></thead><tbody><tr><td>Cookie</td><td>辨别用户身份</td><td>客户端浏览器</td><td>可保存较长时间</td></tr><tr><td>Session</td><td>记录客户状态</td><td>服务器</td><td>关闭浏览器后删除</td></tr></tbody></table>',3))])}const g=s(d,[["render",p]]);export{m as __pageData,g as default};
